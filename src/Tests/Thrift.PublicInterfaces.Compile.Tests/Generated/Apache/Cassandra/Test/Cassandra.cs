/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Apache.Cassandra.Test
{
  public partial class Cassandra {
    public interface ISync {
      void login(AuthenticationRequest auth_request);
      void set_keyspace(string keyspace);
      /// <summary>
      /// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
      /// the only method that can throw an exception under non-failure conditions.)
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_path"></param>
      /// <param name="consistency_level"></param>
      ColumnOrSuperColumn @get(byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level);
      /// <summary>
      /// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
      /// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      List<ColumnOrSuperColumn> get_slice(byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level);
      /// <summary>
      /// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
      /// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      int get_count(byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level);
      /// <summary>
      /// Performs a get_slice for column_parent and predicate for the given keys in parallel.
      /// </summary>
      /// <param name="keys"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      Dictionary<byte[], List<ColumnOrSuperColumn>> multiget_slice(List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level);
      /// <summary>
      /// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
      /// </summary>
      /// <param name="keys"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      Dictionary<byte[], int> multiget_count(List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level);
      /// <summary>
      /// returns a subset of columns for a contiguous range of keys.
      /// </summary>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="range"></param>
      /// <param name="consistency_level"></param>
      List<KeySlice> get_range_slices(ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level);
      /// <summary>
      /// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
      /// </summary>
      /// <param name="column_parent"></param>
      /// <param name="index_clause"></param>
      /// <param name="column_predicate"></param>
      /// <param name="consistency_level"></param>
      List<KeySlice> get_indexed_slices(ColumnParent column_parent, IndexClause index_clause, SlicePredicate column_predicate, ConsistencyLevel consistency_level);
      /// <summary>
      /// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="column"></param>
      /// <param name="consistency_level"></param>
      void insert(byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level);
      /// <summary>
      /// Increment or decrement a counter.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="column"></param>
      /// <param name="consistency_level"></param>
      void @add(byte[] key, ColumnParent column_parent, CounterColumn column, ConsistencyLevel consistency_level);
      /// <summary>
      /// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
      /// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
      /// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_path"></param>
      /// <param name="timestamp"></param>
      /// <param name="consistency_level"></param>
      void @remove(byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level);
      /// <summary>
      /// Remove a counter at the specified location.
      /// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
      /// until the delete has reached all the nodes and all of them have been fully compacted.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="path"></param>
      /// <param name="consistency_level"></param>
      void remove_counter(byte[] key, ColumnPath path, ConsistencyLevel consistency_level);
      /// <summary>
      ///   Mutate many columns or super columns for many row keys. See also: Mutation.
      /// 
      ///   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
      /// *
      /// </summary>
      /// <param name="mutation_map"></param>
      /// <param name="consistency_level"></param>
      void batch_mutate(Dictionary<byte[], Dictionary<string, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level);
      /// <summary>
      /// Truncate will mark and entire column family as deleted.
      /// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
      /// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
      /// only marks the data as deleted.
      /// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
      /// some hosts are down.
      /// </summary>
      /// <param name="cfname"></param>
      void truncate(string cfname);
      /// <summary>
      /// for each schema version present in the cluster, returns a list of nodes at that version.
      /// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
      /// the cluster is all on the same version if the size of the map is 1.
      /// </summary>
      Dictionary<string, List<string>> describe_schema_versions();
      /// <summary>
      /// list the defined keyspaces in this cluster
      /// </summary>
      List<KsDef> describe_keyspaces();
      /// <summary>
      /// get the cluster name
      /// </summary>
      string describe_cluster_name();
      /// <summary>
      /// get the thrift api version
      /// </summary>
      string describe_version();
      /// <summary>
      /// get the token ring: a map of ranges to host addresses,
      /// represented as a set of TokenRange instead of a map from range
      /// to list of endpoints, because you can't use Thrift structs as
      /// map keys:
      /// https://issues.apache.org/jira/browse/THRIFT-162
      /// 
      /// for the same reason, we can't return a set here, even though
      /// order is neither important nor predictable.
      /// </summary>
      /// <param name="keyspace"></param>
      List<TokenRange> describe_ring(string keyspace);
      /// <summary>
      /// returns the partitioner used by this cluster
      /// </summary>
      string describe_partitioner();
      /// <summary>
      /// returns the snitch used by this cluster
      /// </summary>
      string describe_snitch();
      /// <summary>
      /// describe specified keyspace
      /// </summary>
      /// <param name="keyspace"></param>
      KsDef describe_keyspace(string keyspace);
      /// <summary>
      /// experimental API for hadoop/parallel query support.
      /// may change violently and without warning.
      /// 
      /// returns list of token strings such that first subrange is (list[0], list[1]],
      /// next is (list[1], list[2]], etc.
      /// </summary>
      /// <param name="cfName"></param>
      /// <param name="start_token"></param>
      /// <param name="end_token"></param>
      /// <param name="keys_per_split"></param>
      List<string> describe_splits(string cfName, string start_token, string end_token, int keys_per_split);
      /// <summary>
      /// adds a column family. returns the new schema id.
      /// </summary>
      /// <param name="cf_def"></param>
      string system_add_column_family(CfDef cf_def);
      /// <summary>
      /// drops a column family. returns the new schema id.
      /// </summary>
      /// <param name="column_family"></param>
      string system_drop_column_family(string column_family);
      /// <summary>
      /// adds a keyspace and any column families that are part of it. returns the new schema id.
      /// </summary>
      /// <param name="ks_def"></param>
      string system_add_keyspace(KsDef ks_def);
      /// <summary>
      /// drops a keyspace and any column families that are part of it. returns the new schema id.
      /// </summary>
      /// <param name="keyspace"></param>
      string system_drop_keyspace(string keyspace);
      /// <summary>
      /// updates properties of a keyspace. returns the new schema id.
      /// </summary>
      /// <param name="ks_def"></param>
      string system_update_keyspace(KsDef ks_def);
      /// <summary>
      /// updates properties of a column family. returns the new schema id.
      /// </summary>
      /// <param name="cf_def"></param>
      string system_update_column_family(CfDef cf_def);
      /// <summary>
      /// Executes a CQL (Cassandra Query Language) statement and returns a
      /// CqlResult containing the results.
      /// </summary>
      /// <param name="query"></param>
      /// <param name="compression"></param>
      CqlResult execute_cql_query(byte[] query, Compression compression);
      /// <summary>
      /// Prepare a CQL (Cassandra Query Language) statement by compiling and returning
      /// - the type of CQL statement
      /// - an id token of the compiled CQL stored on the server side.
      /// - a count of the discovered bound markers in the statement
      /// </summary>
      /// <param name="query"></param>
      /// <param name="compression"></param>
      CqlPreparedResult prepare_cql_query(byte[] query, Compression compression);
      /// <summary>
      /// Executes a prepared CQL (Cassandra Query Language) statement by passing an id token and  a list of variables
      /// to bind and returns a CqlResult containing the results.
      /// </summary>
      /// <param name="itemId"></param>
      /// <param name="values"></param>
      CqlResult execute_prepared_cql_query(int itemId, List<string> values);
    }

    public interface Iface : ISync {
      #if SILVERLIGHT
      IAsyncResult Begin_login(AsyncCallback callback, object state, AuthenticationRequest auth_request);
      void End_login(IAsyncResult asyncResult);
      #endif
      #if SILVERLIGHT
      IAsyncResult Begin_set_keyspace(AsyncCallback callback, object state, string keyspace);
      void End_set_keyspace(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
      /// the only method that can throw an exception under non-failure conditions.)
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_path"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_get(AsyncCallback callback, object state, byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level);
      ColumnOrSuperColumn End_get(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
      /// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_get_slice(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level);
      List<ColumnOrSuperColumn> End_get_slice(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
      /// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_get_count(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level);
      int End_get_count(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Performs a get_slice for column_parent and predicate for the given keys in parallel.
      /// </summary>
      /// <param name="keys"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_multiget_slice(AsyncCallback callback, object state, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level);
      Dictionary<byte[], List<ColumnOrSuperColumn>> End_multiget_slice(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
      /// </summary>
      /// <param name="keys"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_multiget_count(AsyncCallback callback, object state, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level);
      Dictionary<byte[], int> End_multiget_count(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// returns a subset of columns for a contiguous range of keys.
      /// </summary>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="range"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_get_range_slices(AsyncCallback callback, object state, ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level);
      List<KeySlice> End_get_range_slices(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
      /// </summary>
      /// <param name="column_parent"></param>
      /// <param name="index_clause"></param>
      /// <param name="column_predicate"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_get_indexed_slices(AsyncCallback callback, object state, ColumnParent column_parent, IndexClause index_clause, SlicePredicate column_predicate, ConsistencyLevel consistency_level);
      List<KeySlice> End_get_indexed_slices(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="column"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_insert(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level);
      void End_insert(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Increment or decrement a counter.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="column"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_add(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, CounterColumn column, ConsistencyLevel consistency_level);
      void End_add(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
      /// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
      /// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_path"></param>
      /// <param name="timestamp"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_remove(AsyncCallback callback, object state, byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level);
      void End_remove(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Remove a counter at the specified location.
      /// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
      /// until the delete has reached all the nodes and all of them have been fully compacted.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="path"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_remove_counter(AsyncCallback callback, object state, byte[] key, ColumnPath path, ConsistencyLevel consistency_level);
      void End_remove_counter(IAsyncResult asyncResult);
      #endif
      /// <summary>
      ///   Mutate many columns or super columns for many row keys. See also: Mutation.
      /// 
      ///   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
      /// *
      /// </summary>
      /// <param name="mutation_map"></param>
      /// <param name="consistency_level"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_batch_mutate(AsyncCallback callback, object state, Dictionary<byte[], Dictionary<string, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level);
      void End_batch_mutate(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Truncate will mark and entire column family as deleted.
      /// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
      /// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
      /// only marks the data as deleted.
      /// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
      /// some hosts are down.
      /// </summary>
      /// <param name="cfname"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_truncate(AsyncCallback callback, object state, string cfname);
      void End_truncate(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// for each schema version present in the cluster, returns a list of nodes at that version.
      /// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
      /// the cluster is all on the same version if the size of the map is 1.
      /// </summary>
      #if SILVERLIGHT
      IAsyncResult Begin_describe_schema_versions(AsyncCallback callback, object state);
      Dictionary<string, List<string>> End_describe_schema_versions(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// list the defined keyspaces in this cluster
      /// </summary>
      #if SILVERLIGHT
      IAsyncResult Begin_describe_keyspaces(AsyncCallback callback, object state);
      List<KsDef> End_describe_keyspaces(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// get the cluster name
      /// </summary>
      #if SILVERLIGHT
      IAsyncResult Begin_describe_cluster_name(AsyncCallback callback, object state);
      string End_describe_cluster_name(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// get the thrift api version
      /// </summary>
      #if SILVERLIGHT
      IAsyncResult Begin_describe_version(AsyncCallback callback, object state);
      string End_describe_version(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// get the token ring: a map of ranges to host addresses,
      /// represented as a set of TokenRange instead of a map from range
      /// to list of endpoints, because you can't use Thrift structs as
      /// map keys:
      /// https://issues.apache.org/jira/browse/THRIFT-162
      /// 
      /// for the same reason, we can't return a set here, even though
      /// order is neither important nor predictable.
      /// </summary>
      /// <param name="keyspace"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_describe_ring(AsyncCallback callback, object state, string keyspace);
      List<TokenRange> End_describe_ring(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// returns the partitioner used by this cluster
      /// </summary>
      #if SILVERLIGHT
      IAsyncResult Begin_describe_partitioner(AsyncCallback callback, object state);
      string End_describe_partitioner(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// returns the snitch used by this cluster
      /// </summary>
      #if SILVERLIGHT
      IAsyncResult Begin_describe_snitch(AsyncCallback callback, object state);
      string End_describe_snitch(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// describe specified keyspace
      /// </summary>
      /// <param name="keyspace"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_describe_keyspace(AsyncCallback callback, object state, string keyspace);
      KsDef End_describe_keyspace(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// experimental API for hadoop/parallel query support.
      /// may change violently and without warning.
      /// 
      /// returns list of token strings such that first subrange is (list[0], list[1]],
      /// next is (list[1], list[2]], etc.
      /// </summary>
      /// <param name="cfName"></param>
      /// <param name="start_token"></param>
      /// <param name="end_token"></param>
      /// <param name="keys_per_split"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_describe_splits(AsyncCallback callback, object state, string cfName, string start_token, string end_token, int keys_per_split);
      List<string> End_describe_splits(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// adds a column family. returns the new schema id.
      /// </summary>
      /// <param name="cf_def"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_system_add_column_family(AsyncCallback callback, object state, CfDef cf_def);
      string End_system_add_column_family(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// drops a column family. returns the new schema id.
      /// </summary>
      /// <param name="column_family"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_system_drop_column_family(AsyncCallback callback, object state, string column_family);
      string End_system_drop_column_family(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// adds a keyspace and any column families that are part of it. returns the new schema id.
      /// </summary>
      /// <param name="ks_def"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_system_add_keyspace(AsyncCallback callback, object state, KsDef ks_def);
      string End_system_add_keyspace(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// drops a keyspace and any column families that are part of it. returns the new schema id.
      /// </summary>
      /// <param name="keyspace"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_system_drop_keyspace(AsyncCallback callback, object state, string keyspace);
      string End_system_drop_keyspace(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// updates properties of a keyspace. returns the new schema id.
      /// </summary>
      /// <param name="ks_def"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_system_update_keyspace(AsyncCallback callback, object state, KsDef ks_def);
      string End_system_update_keyspace(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// updates properties of a column family. returns the new schema id.
      /// </summary>
      /// <param name="cf_def"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_system_update_column_family(AsyncCallback callback, object state, CfDef cf_def);
      string End_system_update_column_family(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Executes a CQL (Cassandra Query Language) statement and returns a
      /// CqlResult containing the results.
      /// </summary>
      /// <param name="query"></param>
      /// <param name="compression"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_execute_cql_query(AsyncCallback callback, object state, byte[] query, Compression compression);
      CqlResult End_execute_cql_query(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Prepare a CQL (Cassandra Query Language) statement by compiling and returning
      /// - the type of CQL statement
      /// - an id token of the compiled CQL stored on the server side.
      /// - a count of the discovered bound markers in the statement
      /// </summary>
      /// <param name="query"></param>
      /// <param name="compression"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_prepare_cql_query(AsyncCallback callback, object state, byte[] query, Compression compression);
      CqlPreparedResult End_prepare_cql_query(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Executes a prepared CQL (Cassandra Query Language) statement by passing an id token and  a list of variables
      /// to bind and returns a CqlResult containing the results.
      /// </summary>
      /// <param name="itemId"></param>
      /// <param name="values"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_execute_prepared_cql_query(AsyncCallback callback, object state, int itemId, List<string> values);
      CqlResult End_execute_prepared_cql_query(IAsyncResult asyncResult);
      #endif
    }

    public class Client : IDisposable, Iface {
      public Client(TProtocol prot) : this(prot, prot)
      {
      }

      public Client(TProtocol iprot, TProtocol oprot)
      {
        iprot_ = iprot;
        oprot_ = oprot;
      }

      protected TProtocol iprot_;
      protected TProtocol oprot_;
      protected int seqid_;

      public TProtocol InputProtocol
      {
        get { return iprot_; }
      }
      public TProtocol OutputProtocol
      {
        get { return oprot_; }
      }


      #region " IDisposable Support "
      private bool _IsDisposed;

      // IDisposable
      public void Dispose()
      {
        Dispose(true);
      }
      

      protected virtual void Dispose(bool disposing)
      {
        if (!_IsDisposed)
        {
          if (disposing)
          {
            if (iprot_ != null)
            {
              ((IDisposable)iprot_).Dispose();
            }
            if (oprot_ != null)
            {
              ((IDisposable)oprot_).Dispose();
            }
          }
        }
        _IsDisposed = true;
      }
      #endregion


      
      #if SILVERLIGHT
      public IAsyncResult Begin_login(AsyncCallback callback, object state, AuthenticationRequest auth_request)
      {
        return send_login(callback, state, auth_request);
      }

      public void End_login(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_login();
      }

      #endif

      public void login(AuthenticationRequest auth_request)
      {
        #if !SILVERLIGHT
        send_login(auth_request);
        recv_login();

        #else
        var asyncResult = Begin_login(null, null, auth_request);
        End_login(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_login(AsyncCallback callback, object state, AuthenticationRequest auth_request)
      #else
      public void send_login(AuthenticationRequest auth_request)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("login", TMessageType.Call, seqid_));
        login_args args = new login_args();
        args.Auth_request = auth_request;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_login()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        login_result result = new login_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.authnx) {
          throw result.Authnx;
        }
        if (result.__isset.authzx) {
          throw result.Authzx;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_set_keyspace(AsyncCallback callback, object state, string keyspace)
      {
        return send_set_keyspace(callback, state, keyspace);
      }

      public void End_set_keyspace(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_set_keyspace();
      }

      #endif

      public void set_keyspace(string keyspace)
      {
        #if !SILVERLIGHT
        send_set_keyspace(keyspace);
        recv_set_keyspace();

        #else
        var asyncResult = Begin_set_keyspace(null, null, keyspace);
        End_set_keyspace(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_set_keyspace(AsyncCallback callback, object state, string keyspace)
      #else
      public void send_set_keyspace(string keyspace)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("set_keyspace", TMessageType.Call, seqid_));
        set_keyspace_args args = new set_keyspace_args();
        args.Keyspace = keyspace;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_set_keyspace()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        set_keyspace_result result = new set_keyspace_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.ire) {
          throw result.Ire;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_get(AsyncCallback callback, object state, byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level)
      {
        return send_get(callback, state, key, column_path, consistency_level);
      }

      public ColumnOrSuperColumn End_get(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_get();
      }

      #endif

      /// <summary>
      /// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
      /// the only method that can throw an exception under non-failure conditions.)
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_path"></param>
      /// <param name="consistency_level"></param>
      public ColumnOrSuperColumn @get(byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_get(key, column_path, consistency_level);
        return recv_get();

        #else
        var asyncResult = Begin_get(null, null, key, column_path, consistency_level);
        return End_get(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_get(AsyncCallback callback, object state, byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level)
      #else
      public void send_get(byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("get", TMessageType.Call, seqid_));
        get_args args = new get_args();
        args.Key = key;
        args.Column_path = column_path;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public ColumnOrSuperColumn recv_get()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        get_result result = new get_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.nfe) {
          throw result.Nfe;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "get failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_get_slice(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      {
        return send_get_slice(callback, state, key, column_parent, predicate, consistency_level);
      }

      public List<ColumnOrSuperColumn> End_get_slice(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_get_slice();
      }

      #endif

      /// <summary>
      /// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
      /// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      public List<ColumnOrSuperColumn> get_slice(byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_get_slice(key, column_parent, predicate, consistency_level);
        return recv_get_slice();

        #else
        var asyncResult = Begin_get_slice(null, null, key, column_parent, predicate, consistency_level);
        return End_get_slice(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_get_slice(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      #else
      public void send_get_slice(byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("get_slice", TMessageType.Call, seqid_));
        get_slice_args args = new get_slice_args();
        args.Key = key;
        args.Column_parent = column_parent;
        args.Predicate = predicate;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<ColumnOrSuperColumn> recv_get_slice()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        get_slice_result result = new get_slice_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "get_slice failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_get_count(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      {
        return send_get_count(callback, state, key, column_parent, predicate, consistency_level);
      }

      public int End_get_count(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_get_count();
      }

      #endif

      /// <summary>
      /// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
      /// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      public int get_count(byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_get_count(key, column_parent, predicate, consistency_level);
        return recv_get_count();

        #else
        var asyncResult = Begin_get_count(null, null, key, column_parent, predicate, consistency_level);
        return End_get_count(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_get_count(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      #else
      public void send_get_count(byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("get_count", TMessageType.Call, seqid_));
        get_count_args args = new get_count_args();
        args.Key = key;
        args.Column_parent = column_parent;
        args.Predicate = predicate;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_get_count()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        get_count_result result = new get_count_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "get_count failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_multiget_slice(AsyncCallback callback, object state, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      {
        return send_multiget_slice(callback, state, keys, column_parent, predicate, consistency_level);
      }

      public Dictionary<byte[], List<ColumnOrSuperColumn>> End_multiget_slice(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_multiget_slice();
      }

      #endif

      /// <summary>
      /// Performs a get_slice for column_parent and predicate for the given keys in parallel.
      /// </summary>
      /// <param name="keys"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      public Dictionary<byte[], List<ColumnOrSuperColumn>> multiget_slice(List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_multiget_slice(keys, column_parent, predicate, consistency_level);
        return recv_multiget_slice();

        #else
        var asyncResult = Begin_multiget_slice(null, null, keys, column_parent, predicate, consistency_level);
        return End_multiget_slice(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_multiget_slice(AsyncCallback callback, object state, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      #else
      public void send_multiget_slice(List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("multiget_slice", TMessageType.Call, seqid_));
        multiget_slice_args args = new multiget_slice_args();
        args.Keys = keys;
        args.Column_parent = column_parent;
        args.Predicate = predicate;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Dictionary<byte[], List<ColumnOrSuperColumn>> recv_multiget_slice()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        multiget_slice_result result = new multiget_slice_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "multiget_slice failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_multiget_count(AsyncCallback callback, object state, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      {
        return send_multiget_count(callback, state, keys, column_parent, predicate, consistency_level);
      }

      public Dictionary<byte[], int> End_multiget_count(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_multiget_count();
      }

      #endif

      /// <summary>
      /// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
      /// </summary>
      /// <param name="keys"></param>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="consistency_level"></param>
      public Dictionary<byte[], int> multiget_count(List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_multiget_count(keys, column_parent, predicate, consistency_level);
        return recv_multiget_count();

        #else
        var asyncResult = Begin_multiget_count(null, null, keys, column_parent, predicate, consistency_level);
        return End_multiget_count(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_multiget_count(AsyncCallback callback, object state, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      #else
      public void send_multiget_count(List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("multiget_count", TMessageType.Call, seqid_));
        multiget_count_args args = new multiget_count_args();
        args.Keys = keys;
        args.Column_parent = column_parent;
        args.Predicate = predicate;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Dictionary<byte[], int> recv_multiget_count()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        multiget_count_result result = new multiget_count_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "multiget_count failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_get_range_slices(AsyncCallback callback, object state, ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level)
      {
        return send_get_range_slices(callback, state, column_parent, predicate, range, consistency_level);
      }

      public List<KeySlice> End_get_range_slices(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_get_range_slices();
      }

      #endif

      /// <summary>
      /// returns a subset of columns for a contiguous range of keys.
      /// </summary>
      /// <param name="column_parent"></param>
      /// <param name="predicate"></param>
      /// <param name="range"></param>
      /// <param name="consistency_level"></param>
      public List<KeySlice> get_range_slices(ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_get_range_slices(column_parent, predicate, range, consistency_level);
        return recv_get_range_slices();

        #else
        var asyncResult = Begin_get_range_slices(null, null, column_parent, predicate, range, consistency_level);
        return End_get_range_slices(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_get_range_slices(AsyncCallback callback, object state, ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level)
      #else
      public void send_get_range_slices(ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("get_range_slices", TMessageType.Call, seqid_));
        get_range_slices_args args = new get_range_slices_args();
        args.Column_parent = column_parent;
        args.Predicate = predicate;
        args.Range = range;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<KeySlice> recv_get_range_slices()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        get_range_slices_result result = new get_range_slices_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "get_range_slices failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_get_indexed_slices(AsyncCallback callback, object state, ColumnParent column_parent, IndexClause index_clause, SlicePredicate column_predicate, ConsistencyLevel consistency_level)
      {
        return send_get_indexed_slices(callback, state, column_parent, index_clause, column_predicate, consistency_level);
      }

      public List<KeySlice> End_get_indexed_slices(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_get_indexed_slices();
      }

      #endif

      /// <summary>
      /// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
      /// </summary>
      /// <param name="column_parent"></param>
      /// <param name="index_clause"></param>
      /// <param name="column_predicate"></param>
      /// <param name="consistency_level"></param>
      public List<KeySlice> get_indexed_slices(ColumnParent column_parent, IndexClause index_clause, SlicePredicate column_predicate, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_get_indexed_slices(column_parent, index_clause, column_predicate, consistency_level);
        return recv_get_indexed_slices();

        #else
        var asyncResult = Begin_get_indexed_slices(null, null, column_parent, index_clause, column_predicate, consistency_level);
        return End_get_indexed_slices(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_get_indexed_slices(AsyncCallback callback, object state, ColumnParent column_parent, IndexClause index_clause, SlicePredicate column_predicate, ConsistencyLevel consistency_level)
      #else
      public void send_get_indexed_slices(ColumnParent column_parent, IndexClause index_clause, SlicePredicate column_predicate, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("get_indexed_slices", TMessageType.Call, seqid_));
        get_indexed_slices_args args = new get_indexed_slices_args();
        args.Column_parent = column_parent;
        args.Index_clause = index_clause;
        args.Column_predicate = column_predicate;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<KeySlice> recv_get_indexed_slices()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        get_indexed_slices_result result = new get_indexed_slices_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "get_indexed_slices failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_insert(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level)
      {
        return send_insert(callback, state, key, column_parent, column, consistency_level);
      }

      public void End_insert(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_insert();
      }

      #endif

      /// <summary>
      /// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="column"></param>
      /// <param name="consistency_level"></param>
      public void insert(byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_insert(key, column_parent, column, consistency_level);
        recv_insert();

        #else
        var asyncResult = Begin_insert(null, null, key, column_parent, column, consistency_level);
        End_insert(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_insert(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level)
      #else
      public void send_insert(byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("insert", TMessageType.Call, seqid_));
        insert_args args = new insert_args();
        args.Key = key;
        args.Column_parent = column_parent;
        args.Column = column;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_insert()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        insert_result result = new insert_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_add(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, CounterColumn column, ConsistencyLevel consistency_level)
      {
        return send_add(callback, state, key, column_parent, column, consistency_level);
      }

      public void End_add(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_add();
      }

      #endif

      /// <summary>
      /// Increment or decrement a counter.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_parent"></param>
      /// <param name="column"></param>
      /// <param name="consistency_level"></param>
      public void @add(byte[] key, ColumnParent column_parent, CounterColumn column, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_add(key, column_parent, column, consistency_level);
        recv_add();

        #else
        var asyncResult = Begin_add(null, null, key, column_parent, column, consistency_level);
        End_add(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_add(AsyncCallback callback, object state, byte[] key, ColumnParent column_parent, CounterColumn column, ConsistencyLevel consistency_level)
      #else
      public void send_add(byte[] key, ColumnParent column_parent, CounterColumn column, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("add", TMessageType.Call, seqid_));
        add_args args = new add_args();
        args.Key = key;
        args.Column_parent = column_parent;
        args.Column = column;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_add()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        add_result result = new add_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_remove(AsyncCallback callback, object state, byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level)
      {
        return send_remove(callback, state, key, column_path, timestamp, consistency_level);
      }

      public void End_remove(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_remove();
      }

      #endif

      /// <summary>
      /// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
      /// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
      /// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="column_path"></param>
      /// <param name="timestamp"></param>
      /// <param name="consistency_level"></param>
      public void @remove(byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_remove(key, column_path, timestamp, consistency_level);
        recv_remove();

        #else
        var asyncResult = Begin_remove(null, null, key, column_path, timestamp, consistency_level);
        End_remove(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_remove(AsyncCallback callback, object state, byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level)
      #else
      public void send_remove(byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("remove", TMessageType.Call, seqid_));
        remove_args args = new remove_args();
        args.Key = key;
        args.Column_path = column_path;
        args.Timestamp = timestamp;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_remove()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        remove_result result = new remove_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_remove_counter(AsyncCallback callback, object state, byte[] key, ColumnPath path, ConsistencyLevel consistency_level)
      {
        return send_remove_counter(callback, state, key, path, consistency_level);
      }

      public void End_remove_counter(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_remove_counter();
      }

      #endif

      /// <summary>
      /// Remove a counter at the specified location.
      /// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
      /// until the delete has reached all the nodes and all of them have been fully compacted.
      /// </summary>
      /// <param name="key"></param>
      /// <param name="path"></param>
      /// <param name="consistency_level"></param>
      public void remove_counter(byte[] key, ColumnPath path, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_remove_counter(key, path, consistency_level);
        recv_remove_counter();

        #else
        var asyncResult = Begin_remove_counter(null, null, key, path, consistency_level);
        End_remove_counter(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_remove_counter(AsyncCallback callback, object state, byte[] key, ColumnPath path, ConsistencyLevel consistency_level)
      #else
      public void send_remove_counter(byte[] key, ColumnPath path, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("remove_counter", TMessageType.Call, seqid_));
        remove_counter_args args = new remove_counter_args();
        args.Key = key;
        args.Path = path;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_remove_counter()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        remove_counter_result result = new remove_counter_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_batch_mutate(AsyncCallback callback, object state, Dictionary<byte[], Dictionary<string, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level)
      {
        return send_batch_mutate(callback, state, mutation_map, consistency_level);
      }

      public void End_batch_mutate(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_batch_mutate();
      }

      #endif

      /// <summary>
      ///   Mutate many columns or super columns for many row keys. See also: Mutation.
      /// 
      ///   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
      /// *
      /// </summary>
      /// <param name="mutation_map"></param>
      /// <param name="consistency_level"></param>
      public void batch_mutate(Dictionary<byte[], Dictionary<string, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level)
      {
        #if !SILVERLIGHT
        send_batch_mutate(mutation_map, consistency_level);
        recv_batch_mutate();

        #else
        var asyncResult = Begin_batch_mutate(null, null, mutation_map, consistency_level);
        End_batch_mutate(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_batch_mutate(AsyncCallback callback, object state, Dictionary<byte[], Dictionary<string, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level)
      #else
      public void send_batch_mutate(Dictionary<byte[], Dictionary<string, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("batch_mutate", TMessageType.Call, seqid_));
        batch_mutate_args args = new batch_mutate_args();
        args.Mutation_map = mutation_map;
        args.Consistency_level = consistency_level;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_batch_mutate()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        batch_mutate_result result = new batch_mutate_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_truncate(AsyncCallback callback, object state, string cfname)
      {
        return send_truncate(callback, state, cfname);
      }

      public void End_truncate(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_truncate();
      }

      #endif

      /// <summary>
      /// Truncate will mark and entire column family as deleted.
      /// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
      /// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
      /// only marks the data as deleted.
      /// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
      /// some hosts are down.
      /// </summary>
      /// <param name="cfname"></param>
      public void truncate(string cfname)
      {
        #if !SILVERLIGHT
        send_truncate(cfname);
        recv_truncate();

        #else
        var asyncResult = Begin_truncate(null, null, cfname);
        End_truncate(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_truncate(AsyncCallback callback, object state, string cfname)
      #else
      public void send_truncate(string cfname)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("truncate", TMessageType.Call, seqid_));
        truncate_args args = new truncate_args();
        args.Cfname = cfname;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_truncate()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        truncate_result result = new truncate_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_describe_schema_versions(AsyncCallback callback, object state)
      {
        return send_describe_schema_versions(callback, state);
      }

      public Dictionary<string, List<string>> End_describe_schema_versions(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_describe_schema_versions();
      }

      #endif

      /// <summary>
      /// for each schema version present in the cluster, returns a list of nodes at that version.
      /// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
      /// the cluster is all on the same version if the size of the map is 1.
      /// </summary>
      public Dictionary<string, List<string>> describe_schema_versions()
      {
        #if !SILVERLIGHT
        send_describe_schema_versions();
        return recv_describe_schema_versions();

        #else
        var asyncResult = Begin_describe_schema_versions(null, null);
        return End_describe_schema_versions(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_describe_schema_versions(AsyncCallback callback, object state)
      #else
      public void send_describe_schema_versions()
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("describe_schema_versions", TMessageType.Call, seqid_));
        describe_schema_versions_args args = new describe_schema_versions_args();
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Dictionary<string, List<string>> recv_describe_schema_versions()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        describe_schema_versions_result result = new describe_schema_versions_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "describe_schema_versions failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_describe_keyspaces(AsyncCallback callback, object state)
      {
        return send_describe_keyspaces(callback, state);
      }

      public List<KsDef> End_describe_keyspaces(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_describe_keyspaces();
      }

      #endif

      /// <summary>
      /// list the defined keyspaces in this cluster
      /// </summary>
      public List<KsDef> describe_keyspaces()
      {
        #if !SILVERLIGHT
        send_describe_keyspaces();
        return recv_describe_keyspaces();

        #else
        var asyncResult = Begin_describe_keyspaces(null, null);
        return End_describe_keyspaces(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_describe_keyspaces(AsyncCallback callback, object state)
      #else
      public void send_describe_keyspaces()
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("describe_keyspaces", TMessageType.Call, seqid_));
        describe_keyspaces_args args = new describe_keyspaces_args();
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<KsDef> recv_describe_keyspaces()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        describe_keyspaces_result result = new describe_keyspaces_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "describe_keyspaces failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_describe_cluster_name(AsyncCallback callback, object state)
      {
        return send_describe_cluster_name(callback, state);
      }

      public string End_describe_cluster_name(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_describe_cluster_name();
      }

      #endif

      /// <summary>
      /// get the cluster name
      /// </summary>
      public string describe_cluster_name()
      {
        #if !SILVERLIGHT
        send_describe_cluster_name();
        return recv_describe_cluster_name();

        #else
        var asyncResult = Begin_describe_cluster_name(null, null);
        return End_describe_cluster_name(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_describe_cluster_name(AsyncCallback callback, object state)
      #else
      public void send_describe_cluster_name()
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("describe_cluster_name", TMessageType.Call, seqid_));
        describe_cluster_name_args args = new describe_cluster_name_args();
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_describe_cluster_name()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        describe_cluster_name_result result = new describe_cluster_name_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "describe_cluster_name failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_describe_version(AsyncCallback callback, object state)
      {
        return send_describe_version(callback, state);
      }

      public string End_describe_version(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_describe_version();
      }

      #endif

      /// <summary>
      /// get the thrift api version
      /// </summary>
      public string describe_version()
      {
        #if !SILVERLIGHT
        send_describe_version();
        return recv_describe_version();

        #else
        var asyncResult = Begin_describe_version(null, null);
        return End_describe_version(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_describe_version(AsyncCallback callback, object state)
      #else
      public void send_describe_version()
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("describe_version", TMessageType.Call, seqid_));
        describe_version_args args = new describe_version_args();
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_describe_version()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        describe_version_result result = new describe_version_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "describe_version failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_describe_ring(AsyncCallback callback, object state, string keyspace)
      {
        return send_describe_ring(callback, state, keyspace);
      }

      public List<TokenRange> End_describe_ring(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_describe_ring();
      }

      #endif

      /// <summary>
      /// get the token ring: a map of ranges to host addresses,
      /// represented as a set of TokenRange instead of a map from range
      /// to list of endpoints, because you can't use Thrift structs as
      /// map keys:
      /// https://issues.apache.org/jira/browse/THRIFT-162
      /// 
      /// for the same reason, we can't return a set here, even though
      /// order is neither important nor predictable.
      /// </summary>
      /// <param name="keyspace"></param>
      public List<TokenRange> describe_ring(string keyspace)
      {
        #if !SILVERLIGHT
        send_describe_ring(keyspace);
        return recv_describe_ring();

        #else
        var asyncResult = Begin_describe_ring(null, null, keyspace);
        return End_describe_ring(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_describe_ring(AsyncCallback callback, object state, string keyspace)
      #else
      public void send_describe_ring(string keyspace)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("describe_ring", TMessageType.Call, seqid_));
        describe_ring_args args = new describe_ring_args();
        args.Keyspace = keyspace;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TokenRange> recv_describe_ring()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        describe_ring_result result = new describe_ring_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "describe_ring failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_describe_partitioner(AsyncCallback callback, object state)
      {
        return send_describe_partitioner(callback, state);
      }

      public string End_describe_partitioner(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_describe_partitioner();
      }

      #endif

      /// <summary>
      /// returns the partitioner used by this cluster
      /// </summary>
      public string describe_partitioner()
      {
        #if !SILVERLIGHT
        send_describe_partitioner();
        return recv_describe_partitioner();

        #else
        var asyncResult = Begin_describe_partitioner(null, null);
        return End_describe_partitioner(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_describe_partitioner(AsyncCallback callback, object state)
      #else
      public void send_describe_partitioner()
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("describe_partitioner", TMessageType.Call, seqid_));
        describe_partitioner_args args = new describe_partitioner_args();
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_describe_partitioner()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        describe_partitioner_result result = new describe_partitioner_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "describe_partitioner failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_describe_snitch(AsyncCallback callback, object state)
      {
        return send_describe_snitch(callback, state);
      }

      public string End_describe_snitch(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_describe_snitch();
      }

      #endif

      /// <summary>
      /// returns the snitch used by this cluster
      /// </summary>
      public string describe_snitch()
      {
        #if !SILVERLIGHT
        send_describe_snitch();
        return recv_describe_snitch();

        #else
        var asyncResult = Begin_describe_snitch(null, null);
        return End_describe_snitch(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_describe_snitch(AsyncCallback callback, object state)
      #else
      public void send_describe_snitch()
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("describe_snitch", TMessageType.Call, seqid_));
        describe_snitch_args args = new describe_snitch_args();
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_describe_snitch()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        describe_snitch_result result = new describe_snitch_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "describe_snitch failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_describe_keyspace(AsyncCallback callback, object state, string keyspace)
      {
        return send_describe_keyspace(callback, state, keyspace);
      }

      public KsDef End_describe_keyspace(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_describe_keyspace();
      }

      #endif

      /// <summary>
      /// describe specified keyspace
      /// </summary>
      /// <param name="keyspace"></param>
      public KsDef describe_keyspace(string keyspace)
      {
        #if !SILVERLIGHT
        send_describe_keyspace(keyspace);
        return recv_describe_keyspace();

        #else
        var asyncResult = Begin_describe_keyspace(null, null, keyspace);
        return End_describe_keyspace(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_describe_keyspace(AsyncCallback callback, object state, string keyspace)
      #else
      public void send_describe_keyspace(string keyspace)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("describe_keyspace", TMessageType.Call, seqid_));
        describe_keyspace_args args = new describe_keyspace_args();
        args.Keyspace = keyspace;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public KsDef recv_describe_keyspace()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        describe_keyspace_result result = new describe_keyspace_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.nfe) {
          throw result.Nfe;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "describe_keyspace failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_describe_splits(AsyncCallback callback, object state, string cfName, string start_token, string end_token, int keys_per_split)
      {
        return send_describe_splits(callback, state, cfName, start_token, end_token, keys_per_split);
      }

      public List<string> End_describe_splits(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_describe_splits();
      }

      #endif

      /// <summary>
      /// experimental API for hadoop/parallel query support.
      /// may change violently and without warning.
      /// 
      /// returns list of token strings such that first subrange is (list[0], list[1]],
      /// next is (list[1], list[2]], etc.
      /// </summary>
      /// <param name="cfName"></param>
      /// <param name="start_token"></param>
      /// <param name="end_token"></param>
      /// <param name="keys_per_split"></param>
      public List<string> describe_splits(string cfName, string start_token, string end_token, int keys_per_split)
      {
        #if !SILVERLIGHT
        send_describe_splits(cfName, start_token, end_token, keys_per_split);
        return recv_describe_splits();

        #else
        var asyncResult = Begin_describe_splits(null, null, cfName, start_token, end_token, keys_per_split);
        return End_describe_splits(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_describe_splits(AsyncCallback callback, object state, string cfName, string start_token, string end_token, int keys_per_split)
      #else
      public void send_describe_splits(string cfName, string start_token, string end_token, int keys_per_split)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("describe_splits", TMessageType.Call, seqid_));
        describe_splits_args args = new describe_splits_args();
        args.CfName = cfName;
        args.Start_token = start_token;
        args.End_token = end_token;
        args.Keys_per_split = keys_per_split;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<string> recv_describe_splits()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        describe_splits_result result = new describe_splits_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "describe_splits failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_system_add_column_family(AsyncCallback callback, object state, CfDef cf_def)
      {
        return send_system_add_column_family(callback, state, cf_def);
      }

      public string End_system_add_column_family(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_system_add_column_family();
      }

      #endif

      /// <summary>
      /// adds a column family. returns the new schema id.
      /// </summary>
      /// <param name="cf_def"></param>
      public string system_add_column_family(CfDef cf_def)
      {
        #if !SILVERLIGHT
        send_system_add_column_family(cf_def);
        return recv_system_add_column_family();

        #else
        var asyncResult = Begin_system_add_column_family(null, null, cf_def);
        return End_system_add_column_family(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_system_add_column_family(AsyncCallback callback, object state, CfDef cf_def)
      #else
      public void send_system_add_column_family(CfDef cf_def)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("system_add_column_family", TMessageType.Call, seqid_));
        system_add_column_family_args args = new system_add_column_family_args();
        args.Cf_def = cf_def;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_system_add_column_family()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        system_add_column_family_result result = new system_add_column_family_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.sde) {
          throw result.Sde;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "system_add_column_family failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_system_drop_column_family(AsyncCallback callback, object state, string column_family)
      {
        return send_system_drop_column_family(callback, state, column_family);
      }

      public string End_system_drop_column_family(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_system_drop_column_family();
      }

      #endif

      /// <summary>
      /// drops a column family. returns the new schema id.
      /// </summary>
      /// <param name="column_family"></param>
      public string system_drop_column_family(string column_family)
      {
        #if !SILVERLIGHT
        send_system_drop_column_family(column_family);
        return recv_system_drop_column_family();

        #else
        var asyncResult = Begin_system_drop_column_family(null, null, column_family);
        return End_system_drop_column_family(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_system_drop_column_family(AsyncCallback callback, object state, string column_family)
      #else
      public void send_system_drop_column_family(string column_family)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("system_drop_column_family", TMessageType.Call, seqid_));
        system_drop_column_family_args args = new system_drop_column_family_args();
        args.Column_family = column_family;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_system_drop_column_family()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        system_drop_column_family_result result = new system_drop_column_family_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.sde) {
          throw result.Sde;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "system_drop_column_family failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_system_add_keyspace(AsyncCallback callback, object state, KsDef ks_def)
      {
        return send_system_add_keyspace(callback, state, ks_def);
      }

      public string End_system_add_keyspace(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_system_add_keyspace();
      }

      #endif

      /// <summary>
      /// adds a keyspace and any column families that are part of it. returns the new schema id.
      /// </summary>
      /// <param name="ks_def"></param>
      public string system_add_keyspace(KsDef ks_def)
      {
        #if !SILVERLIGHT
        send_system_add_keyspace(ks_def);
        return recv_system_add_keyspace();

        #else
        var asyncResult = Begin_system_add_keyspace(null, null, ks_def);
        return End_system_add_keyspace(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_system_add_keyspace(AsyncCallback callback, object state, KsDef ks_def)
      #else
      public void send_system_add_keyspace(KsDef ks_def)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("system_add_keyspace", TMessageType.Call, seqid_));
        system_add_keyspace_args args = new system_add_keyspace_args();
        args.Ks_def = ks_def;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_system_add_keyspace()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        system_add_keyspace_result result = new system_add_keyspace_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.sde) {
          throw result.Sde;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "system_add_keyspace failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_system_drop_keyspace(AsyncCallback callback, object state, string keyspace)
      {
        return send_system_drop_keyspace(callback, state, keyspace);
      }

      public string End_system_drop_keyspace(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_system_drop_keyspace();
      }

      #endif

      /// <summary>
      /// drops a keyspace and any column families that are part of it. returns the new schema id.
      /// </summary>
      /// <param name="keyspace"></param>
      public string system_drop_keyspace(string keyspace)
      {
        #if !SILVERLIGHT
        send_system_drop_keyspace(keyspace);
        return recv_system_drop_keyspace();

        #else
        var asyncResult = Begin_system_drop_keyspace(null, null, keyspace);
        return End_system_drop_keyspace(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_system_drop_keyspace(AsyncCallback callback, object state, string keyspace)
      #else
      public void send_system_drop_keyspace(string keyspace)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("system_drop_keyspace", TMessageType.Call, seqid_));
        system_drop_keyspace_args args = new system_drop_keyspace_args();
        args.Keyspace = keyspace;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_system_drop_keyspace()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        system_drop_keyspace_result result = new system_drop_keyspace_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.sde) {
          throw result.Sde;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "system_drop_keyspace failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_system_update_keyspace(AsyncCallback callback, object state, KsDef ks_def)
      {
        return send_system_update_keyspace(callback, state, ks_def);
      }

      public string End_system_update_keyspace(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_system_update_keyspace();
      }

      #endif

      /// <summary>
      /// updates properties of a keyspace. returns the new schema id.
      /// </summary>
      /// <param name="ks_def"></param>
      public string system_update_keyspace(KsDef ks_def)
      {
        #if !SILVERLIGHT
        send_system_update_keyspace(ks_def);
        return recv_system_update_keyspace();

        #else
        var asyncResult = Begin_system_update_keyspace(null, null, ks_def);
        return End_system_update_keyspace(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_system_update_keyspace(AsyncCallback callback, object state, KsDef ks_def)
      #else
      public void send_system_update_keyspace(KsDef ks_def)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("system_update_keyspace", TMessageType.Call, seqid_));
        system_update_keyspace_args args = new system_update_keyspace_args();
        args.Ks_def = ks_def;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_system_update_keyspace()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        system_update_keyspace_result result = new system_update_keyspace_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.sde) {
          throw result.Sde;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "system_update_keyspace failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_system_update_column_family(AsyncCallback callback, object state, CfDef cf_def)
      {
        return send_system_update_column_family(callback, state, cf_def);
      }

      public string End_system_update_column_family(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_system_update_column_family();
      }

      #endif

      /// <summary>
      /// updates properties of a column family. returns the new schema id.
      /// </summary>
      /// <param name="cf_def"></param>
      public string system_update_column_family(CfDef cf_def)
      {
        #if !SILVERLIGHT
        send_system_update_column_family(cf_def);
        return recv_system_update_column_family();

        #else
        var asyncResult = Begin_system_update_column_family(null, null, cf_def);
        return End_system_update_column_family(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_system_update_column_family(AsyncCallback callback, object state, CfDef cf_def)
      #else
      public void send_system_update_column_family(CfDef cf_def)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("system_update_column_family", TMessageType.Call, seqid_));
        system_update_column_family_args args = new system_update_column_family_args();
        args.Cf_def = cf_def;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_system_update_column_family()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        system_update_column_family_result result = new system_update_column_family_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.sde) {
          throw result.Sde;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "system_update_column_family failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_execute_cql_query(AsyncCallback callback, object state, byte[] query, Compression compression)
      {
        return send_execute_cql_query(callback, state, query, compression);
      }

      public CqlResult End_execute_cql_query(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_execute_cql_query();
      }

      #endif

      /// <summary>
      /// Executes a CQL (Cassandra Query Language) statement and returns a
      /// CqlResult containing the results.
      /// </summary>
      /// <param name="query"></param>
      /// <param name="compression"></param>
      public CqlResult execute_cql_query(byte[] query, Compression compression)
      {
        #if !SILVERLIGHT
        send_execute_cql_query(query, compression);
        return recv_execute_cql_query();

        #else
        var asyncResult = Begin_execute_cql_query(null, null, query, compression);
        return End_execute_cql_query(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_execute_cql_query(AsyncCallback callback, object state, byte[] query, Compression compression)
      #else
      public void send_execute_cql_query(byte[] query, Compression compression)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("execute_cql_query", TMessageType.Call, seqid_));
        execute_cql_query_args args = new execute_cql_query_args();
        args.Query = query;
        args.Compression = compression;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public CqlResult recv_execute_cql_query()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        execute_cql_query_result result = new execute_cql_query_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        if (result.__isset.sde) {
          throw result.Sde;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "execute_cql_query failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_prepare_cql_query(AsyncCallback callback, object state, byte[] query, Compression compression)
      {
        return send_prepare_cql_query(callback, state, query, compression);
      }

      public CqlPreparedResult End_prepare_cql_query(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_prepare_cql_query();
      }

      #endif

      /// <summary>
      /// Prepare a CQL (Cassandra Query Language) statement by compiling and returning
      /// - the type of CQL statement
      /// - an id token of the compiled CQL stored on the server side.
      /// - a count of the discovered bound markers in the statement
      /// </summary>
      /// <param name="query"></param>
      /// <param name="compression"></param>
      public CqlPreparedResult prepare_cql_query(byte[] query, Compression compression)
      {
        #if !SILVERLIGHT
        send_prepare_cql_query(query, compression);
        return recv_prepare_cql_query();

        #else
        var asyncResult = Begin_prepare_cql_query(null, null, query, compression);
        return End_prepare_cql_query(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_prepare_cql_query(AsyncCallback callback, object state, byte[] query, Compression compression)
      #else
      public void send_prepare_cql_query(byte[] query, Compression compression)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("prepare_cql_query", TMessageType.Call, seqid_));
        prepare_cql_query_args args = new prepare_cql_query_args();
        args.Query = query;
        args.Compression = compression;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public CqlPreparedResult recv_prepare_cql_query()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        prepare_cql_query_result result = new prepare_cql_query_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "prepare_cql_query failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_execute_prepared_cql_query(AsyncCallback callback, object state, int itemId, List<string> values)
      {
        return send_execute_prepared_cql_query(callback, state, itemId, values);
      }

      public CqlResult End_execute_prepared_cql_query(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_execute_prepared_cql_query();
      }

      #endif

      /// <summary>
      /// Executes a prepared CQL (Cassandra Query Language) statement by passing an id token and  a list of variables
      /// to bind and returns a CqlResult containing the results.
      /// </summary>
      /// <param name="itemId"></param>
      /// <param name="values"></param>
      public CqlResult execute_prepared_cql_query(int itemId, List<string> values)
      {
        #if !SILVERLIGHT
        send_execute_prepared_cql_query(itemId, values);
        return recv_execute_prepared_cql_query();

        #else
        var asyncResult = Begin_execute_prepared_cql_query(null, null, itemId, values);
        return End_execute_prepared_cql_query(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_execute_prepared_cql_query(AsyncCallback callback, object state, int itemId, List<string> values)
      #else
      public void send_execute_prepared_cql_query(int itemId, List<string> values)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("execute_prepared_cql_query", TMessageType.Call, seqid_));
        execute_prepared_cql_query_args args = new execute_prepared_cql_query_args();
        args.ItemId = itemId;
        args.Values = values;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public CqlResult recv_execute_prepared_cql_query()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        execute_prepared_cql_query_result result = new execute_prepared_cql_query_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.ire) {
          throw result.Ire;
        }
        if (result.__isset.ue) {
          throw result.Ue;
        }
        if (result.__isset.te) {
          throw result.Te;
        }
        if (result.__isset.sde) {
          throw result.Sde;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "execute_prepared_cql_query failed: unknown result");
      }

    }
    public class Processor : TProcessor {
      public Processor(ISync iface)
      {
        iface_ = iface;
        processMap_["login"] = login_Process;
        processMap_["set_keyspace"] = set_keyspace_Process;
        processMap_["get"] = get_Process;
        processMap_["get_slice"] = get_slice_Process;
        processMap_["get_count"] = get_count_Process;
        processMap_["multiget_slice"] = multiget_slice_Process;
        processMap_["multiget_count"] = multiget_count_Process;
        processMap_["get_range_slices"] = get_range_slices_Process;
        processMap_["get_indexed_slices"] = get_indexed_slices_Process;
        processMap_["insert"] = insert_Process;
        processMap_["add"] = add_Process;
        processMap_["remove"] = remove_Process;
        processMap_["remove_counter"] = remove_counter_Process;
        processMap_["batch_mutate"] = batch_mutate_Process;
        processMap_["truncate"] = truncate_Process;
        processMap_["describe_schema_versions"] = describe_schema_versions_Process;
        processMap_["describe_keyspaces"] = describe_keyspaces_Process;
        processMap_["describe_cluster_name"] = describe_cluster_name_Process;
        processMap_["describe_version"] = describe_version_Process;
        processMap_["describe_ring"] = describe_ring_Process;
        processMap_["describe_partitioner"] = describe_partitioner_Process;
        processMap_["describe_snitch"] = describe_snitch_Process;
        processMap_["describe_keyspace"] = describe_keyspace_Process;
        processMap_["describe_splits"] = describe_splits_Process;
        processMap_["system_add_column_family"] = system_add_column_family_Process;
        processMap_["system_drop_column_family"] = system_drop_column_family_Process;
        processMap_["system_add_keyspace"] = system_add_keyspace_Process;
        processMap_["system_drop_keyspace"] = system_drop_keyspace_Process;
        processMap_["system_update_keyspace"] = system_update_keyspace_Process;
        processMap_["system_update_column_family"] = system_update_column_family_Process;
        processMap_["execute_cql_query"] = execute_cql_query_Process;
        processMap_["prepare_cql_query"] = prepare_cql_query_Process;
        processMap_["execute_prepared_cql_query"] = execute_prepared_cql_query_Process;
      }

      protected delegate void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);
      private ISync iface_;
      protected Dictionary<string, ProcessFunction> processMap_ = new Dictionary<string, ProcessFunction>();

      public bool Process(TProtocol iprot, TProtocol oprot)
      {
        try
        {
          TMessage msg = iprot.ReadMessageBegin();
          ProcessFunction fn;
          processMap_.TryGetValue(msg.Name, out fn);
          if (fn == null) {
            TProtocolUtil.Skip(iprot, TType.Struct);
            iprot.ReadMessageEnd();
            TApplicationException x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
            oprot.WriteMessageBegin(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID));
            x.Write(oprot);
            oprot.WriteMessageEnd();
            oprot.Transport.Flush();
            return true;
          }
          fn(msg.SeqID, iprot, oprot);
        }
        catch (IOException)
        {
          return false;
        }
        return true;
      }

      public void login_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        login_args args = new login_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        login_result result = new login_result();
        try
        {
          try
          {
            iface_.login(args.Auth_request);
          }
          catch (AuthenticationException authnx)
          {
            result.Authnx = authnx;
          }
          catch (AuthorizationException authzx)
          {
            result.Authzx = authzx;
          }
          oprot.WriteMessageBegin(new TMessage("login", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("login", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void set_keyspace_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        set_keyspace_args args = new set_keyspace_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        set_keyspace_result result = new set_keyspace_result();
        try
        {
          try
          {
            iface_.set_keyspace(args.Keyspace);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          oprot.WriteMessageBegin(new TMessage("set_keyspace", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("set_keyspace", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void get_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        get_args args = new get_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        get_result result = new get_result();
        try
        {
          try
          {
            result.Success = iface_.@get(args.Key, args.Column_path, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (NotFoundException nfe)
          {
            result.Nfe = nfe;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("get", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("get", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void get_slice_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        get_slice_args args = new get_slice_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        get_slice_result result = new get_slice_result();
        try
        {
          try
          {
            result.Success = iface_.get_slice(args.Key, args.Column_parent, args.Predicate, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("get_slice", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("get_slice", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void get_count_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        get_count_args args = new get_count_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        get_count_result result = new get_count_result();
        try
        {
          try
          {
            result.Success = iface_.get_count(args.Key, args.Column_parent, args.Predicate, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("get_count", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("get_count", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void multiget_slice_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        multiget_slice_args args = new multiget_slice_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        multiget_slice_result result = new multiget_slice_result();
        try
        {
          try
          {
            result.Success = iface_.multiget_slice(args.Keys, args.Column_parent, args.Predicate, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("multiget_slice", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("multiget_slice", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void multiget_count_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        multiget_count_args args = new multiget_count_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        multiget_count_result result = new multiget_count_result();
        try
        {
          try
          {
            result.Success = iface_.multiget_count(args.Keys, args.Column_parent, args.Predicate, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("multiget_count", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("multiget_count", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void get_range_slices_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        get_range_slices_args args = new get_range_slices_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        get_range_slices_result result = new get_range_slices_result();
        try
        {
          try
          {
            result.Success = iface_.get_range_slices(args.Column_parent, args.Predicate, args.Range, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("get_range_slices", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("get_range_slices", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void get_indexed_slices_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        get_indexed_slices_args args = new get_indexed_slices_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        get_indexed_slices_result result = new get_indexed_slices_result();
        try
        {
          try
          {
            result.Success = iface_.get_indexed_slices(args.Column_parent, args.Index_clause, args.Column_predicate, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("get_indexed_slices", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("get_indexed_slices", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void insert_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        insert_args args = new insert_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        insert_result result = new insert_result();
        try
        {
          try
          {
            iface_.insert(args.Key, args.Column_parent, args.Column, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("insert", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("insert", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void add_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        add_args args = new add_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        add_result result = new add_result();
        try
        {
          try
          {
            iface_.@add(args.Key, args.Column_parent, args.Column, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("add", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("add", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void remove_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        remove_args args = new remove_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        remove_result result = new remove_result();
        try
        {
          try
          {
            iface_.@remove(args.Key, args.Column_path, args.Timestamp, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("remove", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("remove", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void remove_counter_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        remove_counter_args args = new remove_counter_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        remove_counter_result result = new remove_counter_result();
        try
        {
          try
          {
            iface_.remove_counter(args.Key, args.Path, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("remove_counter", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("remove_counter", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void batch_mutate_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        batch_mutate_args args = new batch_mutate_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        batch_mutate_result result = new batch_mutate_result();
        try
        {
          try
          {
            iface_.batch_mutate(args.Mutation_map, args.Consistency_level);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("batch_mutate", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("batch_mutate", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void truncate_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        truncate_args args = new truncate_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        truncate_result result = new truncate_result();
        try
        {
          try
          {
            iface_.truncate(args.Cfname);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          oprot.WriteMessageBegin(new TMessage("truncate", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("truncate", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void describe_schema_versions_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        describe_schema_versions_args args = new describe_schema_versions_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        describe_schema_versions_result result = new describe_schema_versions_result();
        try
        {
          try
          {
            result.Success = iface_.describe_schema_versions();
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          oprot.WriteMessageBegin(new TMessage("describe_schema_versions", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("describe_schema_versions", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void describe_keyspaces_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        describe_keyspaces_args args = new describe_keyspaces_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        describe_keyspaces_result result = new describe_keyspaces_result();
        try
        {
          try
          {
            result.Success = iface_.describe_keyspaces();
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          oprot.WriteMessageBegin(new TMessage("describe_keyspaces", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("describe_keyspaces", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void describe_cluster_name_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        describe_cluster_name_args args = new describe_cluster_name_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        describe_cluster_name_result result = new describe_cluster_name_result();
        try
        {
          result.Success = iface_.describe_cluster_name();
          oprot.WriteMessageBegin(new TMessage("describe_cluster_name", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("describe_cluster_name", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void describe_version_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        describe_version_args args = new describe_version_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        describe_version_result result = new describe_version_result();
        try
        {
          result.Success = iface_.describe_version();
          oprot.WriteMessageBegin(new TMessage("describe_version", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("describe_version", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void describe_ring_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        describe_ring_args args = new describe_ring_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        describe_ring_result result = new describe_ring_result();
        try
        {
          try
          {
            result.Success = iface_.describe_ring(args.Keyspace);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          oprot.WriteMessageBegin(new TMessage("describe_ring", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("describe_ring", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void describe_partitioner_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        describe_partitioner_args args = new describe_partitioner_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        describe_partitioner_result result = new describe_partitioner_result();
        try
        {
          result.Success = iface_.describe_partitioner();
          oprot.WriteMessageBegin(new TMessage("describe_partitioner", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("describe_partitioner", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void describe_snitch_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        describe_snitch_args args = new describe_snitch_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        describe_snitch_result result = new describe_snitch_result();
        try
        {
          result.Success = iface_.describe_snitch();
          oprot.WriteMessageBegin(new TMessage("describe_snitch", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("describe_snitch", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void describe_keyspace_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        describe_keyspace_args args = new describe_keyspace_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        describe_keyspace_result result = new describe_keyspace_result();
        try
        {
          try
          {
            result.Success = iface_.describe_keyspace(args.Keyspace);
          }
          catch (NotFoundException nfe)
          {
            result.Nfe = nfe;
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          oprot.WriteMessageBegin(new TMessage("describe_keyspace", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("describe_keyspace", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void describe_splits_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        describe_splits_args args = new describe_splits_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        describe_splits_result result = new describe_splits_result();
        try
        {
          try
          {
            result.Success = iface_.describe_splits(args.CfName, args.Start_token, args.End_token, args.Keys_per_split);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          oprot.WriteMessageBegin(new TMessage("describe_splits", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("describe_splits", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void system_add_column_family_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        system_add_column_family_args args = new system_add_column_family_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        system_add_column_family_result result = new system_add_column_family_result();
        try
        {
          try
          {
            result.Success = iface_.system_add_column_family(args.Cf_def);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (SchemaDisagreementException sde)
          {
            result.Sde = sde;
          }
          oprot.WriteMessageBegin(new TMessage("system_add_column_family", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("system_add_column_family", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void system_drop_column_family_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        system_drop_column_family_args args = new system_drop_column_family_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        system_drop_column_family_result result = new system_drop_column_family_result();
        try
        {
          try
          {
            result.Success = iface_.system_drop_column_family(args.Column_family);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (SchemaDisagreementException sde)
          {
            result.Sde = sde;
          }
          oprot.WriteMessageBegin(new TMessage("system_drop_column_family", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("system_drop_column_family", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void system_add_keyspace_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        system_add_keyspace_args args = new system_add_keyspace_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        system_add_keyspace_result result = new system_add_keyspace_result();
        try
        {
          try
          {
            result.Success = iface_.system_add_keyspace(args.Ks_def);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (SchemaDisagreementException sde)
          {
            result.Sde = sde;
          }
          oprot.WriteMessageBegin(new TMessage("system_add_keyspace", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("system_add_keyspace", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void system_drop_keyspace_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        system_drop_keyspace_args args = new system_drop_keyspace_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        system_drop_keyspace_result result = new system_drop_keyspace_result();
        try
        {
          try
          {
            result.Success = iface_.system_drop_keyspace(args.Keyspace);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (SchemaDisagreementException sde)
          {
            result.Sde = sde;
          }
          oprot.WriteMessageBegin(new TMessage("system_drop_keyspace", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("system_drop_keyspace", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void system_update_keyspace_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        system_update_keyspace_args args = new system_update_keyspace_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        system_update_keyspace_result result = new system_update_keyspace_result();
        try
        {
          try
          {
            result.Success = iface_.system_update_keyspace(args.Ks_def);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (SchemaDisagreementException sde)
          {
            result.Sde = sde;
          }
          oprot.WriteMessageBegin(new TMessage("system_update_keyspace", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("system_update_keyspace", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void system_update_column_family_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        system_update_column_family_args args = new system_update_column_family_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        system_update_column_family_result result = new system_update_column_family_result();
        try
        {
          try
          {
            result.Success = iface_.system_update_column_family(args.Cf_def);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (SchemaDisagreementException sde)
          {
            result.Sde = sde;
          }
          oprot.WriteMessageBegin(new TMessage("system_update_column_family", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("system_update_column_family", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void execute_cql_query_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        execute_cql_query_args args = new execute_cql_query_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        execute_cql_query_result result = new execute_cql_query_result();
        try
        {
          try
          {
            result.Success = iface_.execute_cql_query(args.Query, args.Compression);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          catch (SchemaDisagreementException sde)
          {
            result.Sde = sde;
          }
          oprot.WriteMessageBegin(new TMessage("execute_cql_query", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("execute_cql_query", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void prepare_cql_query_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        prepare_cql_query_args args = new prepare_cql_query_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        prepare_cql_query_result result = new prepare_cql_query_result();
        try
        {
          try
          {
            result.Success = iface_.prepare_cql_query(args.Query, args.Compression);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          oprot.WriteMessageBegin(new TMessage("prepare_cql_query", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("prepare_cql_query", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void execute_prepared_cql_query_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        execute_prepared_cql_query_args args = new execute_prepared_cql_query_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        execute_prepared_cql_query_result result = new execute_prepared_cql_query_result();
        try
        {
          try
          {
            result.Success = iface_.execute_prepared_cql_query(args.ItemId, args.Values);
          }
          catch (InvalidRequestException ire)
          {
            result.Ire = ire;
          }
          catch (UnavailableException ue)
          {
            result.Ue = ue;
          }
          catch (TimedOutException te)
          {
            result.Te = te;
          }
          catch (SchemaDisagreementException sde)
          {
            result.Sde = sde;
          }
          oprot.WriteMessageBegin(new TMessage("execute_prepared_cql_query", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("execute_prepared_cql_query", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class login_args : TBase
    {

      public AuthenticationRequest Auth_request { get; set; }

      public login_args() {
      }

      public login_args(AuthenticationRequest auth_request) : this() {
        this.Auth_request = auth_request;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_auth_request = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Auth_request = new AuthenticationRequest();
                  Auth_request.Read(iprot);
                  isset_auth_request = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_auth_request)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("login_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "auth_request";
          field.Type = TType.Struct;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          Auth_request.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("login_args(");
        __sb.Append(", Auth_request: ");
        __sb.Append(Auth_request== null ? "<null>" : Auth_request.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class login_result : TBase
    {
      private AuthenticationException _authnx;
      private AuthorizationException _authzx;

      public AuthenticationException Authnx
      {
        get
        {
          return _authnx;
        }
        set
        {
          __isset.authnx = true;
          this._authnx = value;
        }
      }

      public AuthorizationException Authzx
      {
        get
        {
          return _authzx;
        }
        set
        {
          __isset.authzx = true;
          this._authzx = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authnx;
        public bool authzx;
      }

      public login_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Authnx = new AuthenticationException();
                  Authnx.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Authzx = new AuthorizationException();
                  Authzx.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("login_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.authnx) {
            if (Authnx != null) {
              field.Name = "Authnx";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Authnx.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.authzx) {
            if (Authzx != null) {
              field.Name = "Authzx";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Authzx.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("login_result(");
        bool __first = true;
        if (Authnx != null && __isset.authnx) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Authnx: ");
          __sb.Append(Authnx== null ? "<null>" : Authnx.ToString());
        }
        if (Authzx != null && __isset.authzx) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Authzx: ");
          __sb.Append(Authzx== null ? "<null>" : Authzx.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class set_keyspace_args : TBase
    {

      public string Keyspace { get; set; }

      public set_keyspace_args() {
      }

      public set_keyspace_args(string keyspace) : this() {
        this.Keyspace = keyspace;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_keyspace = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Keyspace = iprot.ReadString();
                  isset_keyspace = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_keyspace)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("set_keyspace_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "keyspace";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Keyspace);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("set_keyspace_args(");
        __sb.Append(", Keyspace: ");
        __sb.Append(Keyspace);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class set_keyspace_result : TBase
    {
      private InvalidRequestException _ire;

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool ire;
      }

      public set_keyspace_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("set_keyspace_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("set_keyspace_result(");
        bool __first = true;
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_args : TBase
    {

      public byte[] Key { get; set; }

      public ColumnPath Column_path { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public get_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public get_args(byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level) : this() {
        this.Key = key;
        this.Column_path = column_path;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_key = false;
          bool isset_column_path = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Key = iprot.ReadBinary();
                  isset_key = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Column_path = new ColumnPath();
                  Column_path.Read(iprot);
                  isset_column_path = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_key)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column_path)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "key";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Key);
          oprot.WriteFieldEnd();
          field.Name = "column_path";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Column_path.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_args(");
        __sb.Append(", Key: ");
        __sb.Append(Key);
        __sb.Append(", Column_path: ");
        __sb.Append(Column_path== null ? "<null>" : Column_path.ToString());
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_result : TBase
    {
      private ColumnOrSuperColumn _success;
      private InvalidRequestException _ire;
      private NotFoundException _nfe;
      private UnavailableException _ue;
      private TimedOutException _te;

      public ColumnOrSuperColumn Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public NotFoundException Nfe
      {
        get
        {
          return _nfe;
        }
        set
        {
          __isset.nfe = true;
          this._nfe = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool nfe;
        public bool ue;
        public bool te;
      }

      public get_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new ColumnOrSuperColumn();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Nfe = new NotFoundException();
                  Nfe.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.nfe) {
            if (Nfe != null) {
              field.Name = "Nfe";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Nfe.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 4;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Nfe != null && __isset.nfe) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Nfe: ");
          __sb.Append(Nfe== null ? "<null>" : Nfe.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_slice_args : TBase
    {

      public byte[] Key { get; set; }

      public ColumnParent Column_parent { get; set; }

      public SlicePredicate Predicate { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public get_slice_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public get_slice_args(byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) : this() {
        this.Key = key;
        this.Column_parent = column_parent;
        this.Predicate = predicate;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_key = false;
          bool isset_column_parent = false;
          bool isset_predicate = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Key = iprot.ReadBinary();
                  isset_key = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Column_parent = new ColumnParent();
                  Column_parent.Read(iprot);
                  isset_column_parent = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Predicate = new SlicePredicate();
                  Predicate.Read(iprot);
                  isset_predicate = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_key)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column_parent)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_predicate)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_slice_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "key";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Key);
          oprot.WriteFieldEnd();
          field.Name = "column_parent";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Column_parent.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "predicate";
          field.Type = TType.Struct;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          Predicate.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_slice_args(");
        __sb.Append(", Key: ");
        __sb.Append(Key);
        __sb.Append(", Column_parent: ");
        __sb.Append(Column_parent== null ? "<null>" : Column_parent.ToString());
        __sb.Append(", Predicate: ");
        __sb.Append(Predicate== null ? "<null>" : Predicate.ToString());
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_slice_result : TBase
    {
      private List<ColumnOrSuperColumn> _success;
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public List<ColumnOrSuperColumn> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool ue;
        public bool te;
      }

      public get_slice_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<ColumnOrSuperColumn>();
                    TList _list83 = iprot.ReadListBegin();
                    for( int _i84 = 0; _i84 < _list83.Count; ++_i84)
                    {
                      ColumnOrSuperColumn _elem85;
                      _elem85 = new ColumnOrSuperColumn();
                      _elem85.Read(iprot);
                      Success.Add(_elem85);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_slice_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (ColumnOrSuperColumn _iter86 in Success)
                {
                  _iter86.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_slice_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_count_args : TBase
    {

      public byte[] Key { get; set; }

      public ColumnParent Column_parent { get; set; }

      public SlicePredicate Predicate { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public get_count_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public get_count_args(byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) : this() {
        this.Key = key;
        this.Column_parent = column_parent;
        this.Predicate = predicate;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_key = false;
          bool isset_column_parent = false;
          bool isset_predicate = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Key = iprot.ReadBinary();
                  isset_key = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Column_parent = new ColumnParent();
                  Column_parent.Read(iprot);
                  isset_column_parent = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Predicate = new SlicePredicate();
                  Predicate.Read(iprot);
                  isset_predicate = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_key)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column_parent)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_predicate)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_count_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "key";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Key);
          oprot.WriteFieldEnd();
          field.Name = "column_parent";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Column_parent.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "predicate";
          field.Type = TType.Struct;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          Predicate.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_count_args(");
        __sb.Append(", Key: ");
        __sb.Append(Key);
        __sb.Append(", Column_parent: ");
        __sb.Append(Column_parent== null ? "<null>" : Column_parent.ToString());
        __sb.Append(", Predicate: ");
        __sb.Append(Predicate== null ? "<null>" : Predicate.ToString());
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_count_result : TBase
    {
      private int _success;
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool ue;
        public bool te;
      }

      public get_count_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_count_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_count_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class multiget_slice_args : TBase
    {

      public List<byte[]> Keys { get; set; }

      public ColumnParent Column_parent { get; set; }

      public SlicePredicate Predicate { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public multiget_slice_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public multiget_slice_args(List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) : this() {
        this.Keys = keys;
        this.Column_parent = column_parent;
        this.Predicate = predicate;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_keys = false;
          bool isset_column_parent = false;
          bool isset_predicate = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.List) {
                  {
                    Keys = new List<byte[]>();
                    TList _list87 = iprot.ReadListBegin();
                    for( int _i88 = 0; _i88 < _list87.Count; ++_i88)
                    {
                      byte[] _elem89;
                      _elem89 = iprot.ReadBinary();
                      Keys.Add(_elem89);
                    }
                    iprot.ReadListEnd();
                  }
                  isset_keys = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Column_parent = new ColumnParent();
                  Column_parent.Read(iprot);
                  isset_column_parent = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Predicate = new SlicePredicate();
                  Predicate.Read(iprot);
                  isset_predicate = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_keys)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column_parent)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_predicate)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("multiget_slice_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "keys";
          field.Type = TType.List;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.String, Keys.Count));
            foreach (byte[] _iter90 in Keys)
            {
              oprot.WriteBinary(_iter90);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
          field.Name = "column_parent";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Column_parent.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "predicate";
          field.Type = TType.Struct;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          Predicate.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("multiget_slice_args(");
        __sb.Append(", Keys: ");
        __sb.Append(Keys);
        __sb.Append(", Column_parent: ");
        __sb.Append(Column_parent== null ? "<null>" : Column_parent.ToString());
        __sb.Append(", Predicate: ");
        __sb.Append(Predicate== null ? "<null>" : Predicate.ToString());
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class multiget_slice_result : TBase
    {
      private Dictionary<byte[], List<ColumnOrSuperColumn>> _success;
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public Dictionary<byte[], List<ColumnOrSuperColumn>> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool ue;
        public bool te;
      }

      public multiget_slice_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Map) {
                  {
                    Success = new Dictionary<byte[], List<ColumnOrSuperColumn>>();
                    TMap _map91 = iprot.ReadMapBegin();
                    for( int _i92 = 0; _i92 < _map91.Count; ++_i92)
                    {
                      byte[] _key93;
                      List<ColumnOrSuperColumn> _val94;
                      _key93 = iprot.ReadBinary();
                      {
                        _val94 = new List<ColumnOrSuperColumn>();
                        TList _list95 = iprot.ReadListBegin();
                        for( int _i96 = 0; _i96 < _list95.Count; ++_i96)
                        {
                          ColumnOrSuperColumn _elem97;
                          _elem97 = new ColumnOrSuperColumn();
                          _elem97.Read(iprot);
                          _val94.Add(_elem97);
                        }
                        iprot.ReadListEnd();
                      }
                      Success[_key93] = _val94;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("multiget_slice_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Map;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteMapBegin(new TMap(TType.String, TType.List, Success.Count));
                foreach (byte[] _iter98 in Success.Keys)
                {
                  oprot.WriteBinary(_iter98);
                  {
                    oprot.WriteListBegin(new TList(TType.Struct, Success[_iter98].Count));
                    foreach (ColumnOrSuperColumn _iter99 in Success[_iter98])
                    {
                      _iter99.Write(oprot);
                    }
                    oprot.WriteListEnd();
                  }
                }
                oprot.WriteMapEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("multiget_slice_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class multiget_count_args : TBase
    {

      public List<byte[]> Keys { get; set; }

      public ColumnParent Column_parent { get; set; }

      public SlicePredicate Predicate { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public multiget_count_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public multiget_count_args(List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level) : this() {
        this.Keys = keys;
        this.Column_parent = column_parent;
        this.Predicate = predicate;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_keys = false;
          bool isset_column_parent = false;
          bool isset_predicate = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.List) {
                  {
                    Keys = new List<byte[]>();
                    TList _list100 = iprot.ReadListBegin();
                    for( int _i101 = 0; _i101 < _list100.Count; ++_i101)
                    {
                      byte[] _elem102;
                      _elem102 = iprot.ReadBinary();
                      Keys.Add(_elem102);
                    }
                    iprot.ReadListEnd();
                  }
                  isset_keys = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Column_parent = new ColumnParent();
                  Column_parent.Read(iprot);
                  isset_column_parent = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Predicate = new SlicePredicate();
                  Predicate.Read(iprot);
                  isset_predicate = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_keys)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column_parent)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_predicate)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("multiget_count_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "keys";
          field.Type = TType.List;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.String, Keys.Count));
            foreach (byte[] _iter103 in Keys)
            {
              oprot.WriteBinary(_iter103);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
          field.Name = "column_parent";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Column_parent.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "predicate";
          field.Type = TType.Struct;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          Predicate.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("multiget_count_args(");
        __sb.Append(", Keys: ");
        __sb.Append(Keys);
        __sb.Append(", Column_parent: ");
        __sb.Append(Column_parent== null ? "<null>" : Column_parent.ToString());
        __sb.Append(", Predicate: ");
        __sb.Append(Predicate== null ? "<null>" : Predicate.ToString());
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class multiget_count_result : TBase
    {
      private Dictionary<byte[], int> _success;
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public Dictionary<byte[], int> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool ue;
        public bool te;
      }

      public multiget_count_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Map) {
                  {
                    Success = new Dictionary<byte[], int>();
                    TMap _map104 = iprot.ReadMapBegin();
                    for( int _i105 = 0; _i105 < _map104.Count; ++_i105)
                    {
                      byte[] _key106;
                      int _val107;
                      _key106 = iprot.ReadBinary();
                      _val107 = iprot.ReadI32();
                      Success[_key106] = _val107;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("multiget_count_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Map;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteMapBegin(new TMap(TType.String, TType.I32, Success.Count));
                foreach (byte[] _iter108 in Success.Keys)
                {
                  oprot.WriteBinary(_iter108);
                  oprot.WriteI32(Success[_iter108]);
                }
                oprot.WriteMapEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("multiget_count_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_range_slices_args : TBase
    {

      public ColumnParent Column_parent { get; set; }

      public SlicePredicate Predicate { get; set; }

      public KeyRange Range { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public get_range_slices_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public get_range_slices_args(ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level) : this() {
        this.Column_parent = column_parent;
        this.Predicate = predicate;
        this.Range = range;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_column_parent = false;
          bool isset_predicate = false;
          bool isset_range = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Column_parent = new ColumnParent();
                  Column_parent.Read(iprot);
                  isset_column_parent = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Predicate = new SlicePredicate();
                  Predicate.Read(iprot);
                  isset_predicate = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Range = new KeyRange();
                  Range.Read(iprot);
                  isset_range = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_column_parent)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_predicate)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_range)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_range_slices_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "column_parent";
          field.Type = TType.Struct;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          Column_parent.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "predicate";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Predicate.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "range";
          field.Type = TType.Struct;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          Range.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_range_slices_args(");
        __sb.Append(", Column_parent: ");
        __sb.Append(Column_parent== null ? "<null>" : Column_parent.ToString());
        __sb.Append(", Predicate: ");
        __sb.Append(Predicate== null ? "<null>" : Predicate.ToString());
        __sb.Append(", Range: ");
        __sb.Append(Range== null ? "<null>" : Range.ToString());
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_range_slices_result : TBase
    {
      private List<KeySlice> _success;
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public List<KeySlice> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool ue;
        public bool te;
      }

      public get_range_slices_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<KeySlice>();
                    TList _list109 = iprot.ReadListBegin();
                    for( int _i110 = 0; _i110 < _list109.Count; ++_i110)
                    {
                      KeySlice _elem111;
                      _elem111 = new KeySlice();
                      _elem111.Read(iprot);
                      Success.Add(_elem111);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_range_slices_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (KeySlice _iter112 in Success)
                {
                  _iter112.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_range_slices_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_indexed_slices_args : TBase
    {

      public ColumnParent Column_parent { get; set; }

      public IndexClause Index_clause { get; set; }

      public SlicePredicate Column_predicate { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public get_indexed_slices_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public get_indexed_slices_args(ColumnParent column_parent, IndexClause index_clause, SlicePredicate column_predicate, ConsistencyLevel consistency_level) : this() {
        this.Column_parent = column_parent;
        this.Index_clause = index_clause;
        this.Column_predicate = column_predicate;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_column_parent = false;
          bool isset_index_clause = false;
          bool isset_column_predicate = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Column_parent = new ColumnParent();
                  Column_parent.Read(iprot);
                  isset_column_parent = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Index_clause = new IndexClause();
                  Index_clause.Read(iprot);
                  isset_index_clause = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Column_predicate = new SlicePredicate();
                  Column_predicate.Read(iprot);
                  isset_column_predicate = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_column_parent)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_index_clause)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column_predicate)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_indexed_slices_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "column_parent";
          field.Type = TType.Struct;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          Column_parent.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "index_clause";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Index_clause.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "column_predicate";
          field.Type = TType.Struct;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          Column_predicate.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_indexed_slices_args(");
        __sb.Append(", Column_parent: ");
        __sb.Append(Column_parent== null ? "<null>" : Column_parent.ToString());
        __sb.Append(", Index_clause: ");
        __sb.Append(Index_clause== null ? "<null>" : Index_clause.ToString());
        __sb.Append(", Column_predicate: ");
        __sb.Append(Column_predicate== null ? "<null>" : Column_predicate.ToString());
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_indexed_slices_result : TBase
    {
      private List<KeySlice> _success;
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public List<KeySlice> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool ue;
        public bool te;
      }

      public get_indexed_slices_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<KeySlice>();
                    TList _list113 = iprot.ReadListBegin();
                    for( int _i114 = 0; _i114 < _list113.Count; ++_i114)
                    {
                      KeySlice _elem115;
                      _elem115 = new KeySlice();
                      _elem115.Read(iprot);
                      Success.Add(_elem115);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_indexed_slices_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (KeySlice _iter116 in Success)
                {
                  _iter116.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_indexed_slices_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class insert_args : TBase
    {

      public byte[] Key { get; set; }

      public ColumnParent Column_parent { get; set; }

      public Column Column { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public insert_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public insert_args(byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level) : this() {
        this.Key = key;
        this.Column_parent = column_parent;
        this.Column = column;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_key = false;
          bool isset_column_parent = false;
          bool isset_column = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Key = iprot.ReadBinary();
                  isset_key = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Column_parent = new ColumnParent();
                  Column_parent.Read(iprot);
                  isset_column_parent = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Column = new Column();
                  Column.Read(iprot);
                  isset_column = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_key)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column_parent)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("insert_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "key";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Key);
          oprot.WriteFieldEnd();
          field.Name = "column_parent";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Column_parent.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "column";
          field.Type = TType.Struct;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          Column.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("insert_args(");
        __sb.Append(", Key: ");
        __sb.Append(Key);
        __sb.Append(", Column_parent: ");
        __sb.Append(Column_parent== null ? "<null>" : Column_parent.ToString());
        __sb.Append(", Column: ");
        __sb.Append(Column== null ? "<null>" : Column.ToString());
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class insert_result : TBase
    {
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool ire;
        public bool ue;
        public bool te;
      }

      public insert_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("insert_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("insert_result(");
        bool __first = true;
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class add_args : TBase
    {

      public byte[] Key { get; set; }

      public ColumnParent Column_parent { get; set; }

      public CounterColumn Column { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public add_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public add_args(byte[] key, ColumnParent column_parent, CounterColumn column, ConsistencyLevel consistency_level) : this() {
        this.Key = key;
        this.Column_parent = column_parent;
        this.Column = column;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_key = false;
          bool isset_column_parent = false;
          bool isset_column = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Key = iprot.ReadBinary();
                  isset_key = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Column_parent = new ColumnParent();
                  Column_parent.Read(iprot);
                  isset_column_parent = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Column = new CounterColumn();
                  Column.Read(iprot);
                  isset_column = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_key)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column_parent)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("add_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "key";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Key);
          oprot.WriteFieldEnd();
          field.Name = "column_parent";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Column_parent.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "column";
          field.Type = TType.Struct;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          Column.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("add_args(");
        __sb.Append(", Key: ");
        __sb.Append(Key);
        __sb.Append(", Column_parent: ");
        __sb.Append(Column_parent== null ? "<null>" : Column_parent.ToString());
        __sb.Append(", Column: ");
        __sb.Append(Column== null ? "<null>" : Column.ToString());
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class add_result : TBase
    {
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool ire;
        public bool ue;
        public bool te;
      }

      public add_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("add_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("add_result(");
        bool __first = true;
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class remove_args : TBase
    {
      private ConsistencyLevel _consistency_level;

      public byte[] Key { get; set; }

      public ColumnPath Column_path { get; set; }

      public long Timestamp { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level
      {
        get
        {
          return _consistency_level;
        }
        set
        {
          __isset.consistency_level = true;
          this._consistency_level = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool consistency_level;
      }

      public remove_args() {
        this._consistency_level = ConsistencyLevel.ONE;
        this.__isset.consistency_level = true;
      }

      public remove_args(byte[] key, ColumnPath column_path, long timestamp) : this() {
        this.Key = key;
        this.Column_path = column_path;
        this.Timestamp = timestamp;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_key = false;
          bool isset_column_path = false;
          bool isset_timestamp = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Key = iprot.ReadBinary();
                  isset_key = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Column_path = new ColumnPath();
                  Column_path.Read(iprot);
                  isset_column_path = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                  isset_timestamp = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_key)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_column_path)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_timestamp)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("remove_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "key";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Key);
          oprot.WriteFieldEnd();
          field.Name = "column_path";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Column_path.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "timestamp";
          field.Type = TType.I64;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(Timestamp);
          oprot.WriteFieldEnd();
          if (__isset.consistency_level) {
            field.Name = "consistency_level";
            field.Type = TType.I32;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32((int)Consistency_level);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("remove_args(");
        __sb.Append(", Key: ");
        __sb.Append(Key);
        __sb.Append(", Column_path: ");
        __sb.Append(Column_path== null ? "<null>" : Column_path.ToString());
        __sb.Append(", Timestamp: ");
        __sb.Append(Timestamp);
        if (__isset.consistency_level) {
          __sb.Append(", Consistency_level: ");
          __sb.Append(Consistency_level);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class remove_result : TBase
    {
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool ire;
        public bool ue;
        public bool te;
      }

      public remove_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("remove_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("remove_result(");
        bool __first = true;
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class remove_counter_args : TBase
    {

      public byte[] Key { get; set; }

      public ColumnPath Path { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public remove_counter_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public remove_counter_args(byte[] key, ColumnPath path, ConsistencyLevel consistency_level) : this() {
        this.Key = key;
        this.Path = path;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_key = false;
          bool isset_path = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Key = iprot.ReadBinary();
                  isset_key = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Path = new ColumnPath();
                  Path.Read(iprot);
                  isset_path = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_key)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_path)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("remove_counter_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "key";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Key);
          oprot.WriteFieldEnd();
          field.Name = "path";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Path.Write(oprot);
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("remove_counter_args(");
        __sb.Append(", Key: ");
        __sb.Append(Key);
        __sb.Append(", Path: ");
        __sb.Append(Path== null ? "<null>" : Path.ToString());
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class remove_counter_result : TBase
    {
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool ire;
        public bool ue;
        public bool te;
      }

      public remove_counter_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("remove_counter_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("remove_counter_result(");
        bool __first = true;
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class batch_mutate_args : TBase
    {

      public Dictionary<byte[], Dictionary<string, List<Mutation>>> Mutation_map { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="ConsistencyLevel"/>
      /// </summary>
      public ConsistencyLevel Consistency_level { get; set; }

      public batch_mutate_args() {
        this.Consistency_level = ConsistencyLevel.ONE;
      }

      public batch_mutate_args(Dictionary<byte[], Dictionary<string, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level) : this() {
        this.Mutation_map = mutation_map;
        this.Consistency_level = consistency_level;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_mutation_map = false;
          bool isset_consistency_level = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Map) {
                  {
                    Mutation_map = new Dictionary<byte[], Dictionary<string, List<Mutation>>>();
                    TMap _map117 = iprot.ReadMapBegin();
                    for( int _i118 = 0; _i118 < _map117.Count; ++_i118)
                    {
                      byte[] _key119;
                      Dictionary<string, List<Mutation>> _val120;
                      _key119 = iprot.ReadBinary();
                      {
                        _val120 = new Dictionary<string, List<Mutation>>();
                        TMap _map121 = iprot.ReadMapBegin();
                        for( int _i122 = 0; _i122 < _map121.Count; ++_i122)
                        {
                          string _key123;
                          List<Mutation> _val124;
                          _key123 = iprot.ReadString();
                          {
                            _val124 = new List<Mutation>();
                            TList _list125 = iprot.ReadListBegin();
                            for( int _i126 = 0; _i126 < _list125.Count; ++_i126)
                            {
                              Mutation _elem127;
                              _elem127 = new Mutation();
                              _elem127.Read(iprot);
                              _val124.Add(_elem127);
                            }
                            iprot.ReadListEnd();
                          }
                          _val120[_key123] = _val124;
                        }
                        iprot.ReadMapEnd();
                      }
                      Mutation_map[_key119] = _val120;
                    }
                    iprot.ReadMapEnd();
                  }
                  isset_mutation_map = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.I32) {
                  Consistency_level = (ConsistencyLevel)iprot.ReadI32();
                  isset_consistency_level = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_mutation_map)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_consistency_level)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("batch_mutate_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "mutation_map";
          field.Type = TType.Map;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteMapBegin(new TMap(TType.String, TType.Map, Mutation_map.Count));
            foreach (byte[] _iter128 in Mutation_map.Keys)
            {
              oprot.WriteBinary(_iter128);
              {
                oprot.WriteMapBegin(new TMap(TType.String, TType.List, Mutation_map[_iter128].Count));
                foreach (string _iter129 in Mutation_map[_iter128].Keys)
                {
                  oprot.WriteString(_iter129);
                  {
                    oprot.WriteListBegin(new TList(TType.Struct, Mutation_map[_iter128][_iter129].Count));
                    foreach (Mutation _iter130 in Mutation_map[_iter128][_iter129])
                    {
                      _iter130.Write(oprot);
                    }
                    oprot.WriteListEnd();
                  }
                }
                oprot.WriteMapEnd();
              }
            }
            oprot.WriteMapEnd();
          }
          oprot.WriteFieldEnd();
          field.Name = "consistency_level";
          field.Type = TType.I32;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Consistency_level);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("batch_mutate_args(");
        __sb.Append(", Mutation_map: ");
        __sb.Append(Mutation_map);
        __sb.Append(", Consistency_level: ");
        __sb.Append(Consistency_level);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class batch_mutate_result : TBase
    {
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool ire;
        public bool ue;
        public bool te;
      }

      public batch_mutate_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("batch_mutate_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("batch_mutate_result(");
        bool __first = true;
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class truncate_args : TBase
    {

      public string Cfname { get; set; }

      public truncate_args() {
      }

      public truncate_args(string cfname) : this() {
        this.Cfname = cfname;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_cfname = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Cfname = iprot.ReadString();
                  isset_cfname = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_cfname)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("truncate_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "cfname";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Cfname);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("truncate_args(");
        __sb.Append(", Cfname: ");
        __sb.Append(Cfname);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class truncate_result : TBase
    {
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool ire;
        public bool ue;
        public bool te;
      }

      public truncate_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("truncate_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("truncate_result(");
        bool __first = true;
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_schema_versions_args : TBase
    {

      public describe_schema_versions_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_schema_versions_args");
          oprot.WriteStructBegin(struc);
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_schema_versions_args(");
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_schema_versions_result : TBase
    {
      private Dictionary<string, List<string>> _success;
      private InvalidRequestException _ire;

      public Dictionary<string, List<string>> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
      }

      public describe_schema_versions_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Map) {
                  {
                    Success = new Dictionary<string, List<string>>();
                    TMap _map131 = iprot.ReadMapBegin();
                    for( int _i132 = 0; _i132 < _map131.Count; ++_i132)
                    {
                      string _key133;
                      List<string> _val134;
                      _key133 = iprot.ReadString();
                      {
                        _val134 = new List<string>();
                        TList _list135 = iprot.ReadListBegin();
                        for( int _i136 = 0; _i136 < _list135.Count; ++_i136)
                        {
                          string _elem137;
                          _elem137 = iprot.ReadString();
                          _val134.Add(_elem137);
                        }
                        iprot.ReadListEnd();
                      }
                      Success[_key133] = _val134;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_schema_versions_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Map;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteMapBegin(new TMap(TType.String, TType.List, Success.Count));
                foreach (string _iter138 in Success.Keys)
                {
                  oprot.WriteString(_iter138);
                  {
                    oprot.WriteListBegin(new TList(TType.String, Success[_iter138].Count));
                    foreach (string _iter139 in Success[_iter138])
                    {
                      oprot.WriteString(_iter139);
                    }
                    oprot.WriteListEnd();
                  }
                }
                oprot.WriteMapEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_schema_versions_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_keyspaces_args : TBase
    {

      public describe_keyspaces_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_keyspaces_args");
          oprot.WriteStructBegin(struc);
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_keyspaces_args(");
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_keyspaces_result : TBase
    {
      private List<KsDef> _success;
      private InvalidRequestException _ire;

      public List<KsDef> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
      }

      public describe_keyspaces_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<KsDef>();
                    TList _list140 = iprot.ReadListBegin();
                    for( int _i141 = 0; _i141 < _list140.Count; ++_i141)
                    {
                      KsDef _elem142;
                      _elem142 = new KsDef();
                      _elem142.Read(iprot);
                      Success.Add(_elem142);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_keyspaces_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (KsDef _iter143 in Success)
                {
                  _iter143.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_keyspaces_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_cluster_name_args : TBase
    {

      public describe_cluster_name_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_cluster_name_args");
          oprot.WriteStructBegin(struc);
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_cluster_name_args(");
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_cluster_name_result : TBase
    {
      private string _success;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public describe_cluster_name_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_cluster_name_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_cluster_name_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_version_args : TBase
    {

      public describe_version_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_version_args");
          oprot.WriteStructBegin(struc);
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_version_args(");
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_version_result : TBase
    {
      private string _success;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public describe_version_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_version_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_version_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_ring_args : TBase
    {

      public string Keyspace { get; set; }

      public describe_ring_args() {
      }

      public describe_ring_args(string keyspace) : this() {
        this.Keyspace = keyspace;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_keyspace = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Keyspace = iprot.ReadString();
                  isset_keyspace = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_keyspace)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_ring_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "keyspace";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Keyspace);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_ring_args(");
        __sb.Append(", Keyspace: ");
        __sb.Append(Keyspace);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_ring_result : TBase
    {
      private List<TokenRange> _success;
      private InvalidRequestException _ire;

      public List<TokenRange> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
      }

      public describe_ring_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TokenRange>();
                    TList _list144 = iprot.ReadListBegin();
                    for( int _i145 = 0; _i145 < _list144.Count; ++_i145)
                    {
                      TokenRange _elem146;
                      _elem146 = new TokenRange();
                      _elem146.Read(iprot);
                      Success.Add(_elem146);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_ring_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TokenRange _iter147 in Success)
                {
                  _iter147.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_ring_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_partitioner_args : TBase
    {

      public describe_partitioner_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_partitioner_args");
          oprot.WriteStructBegin(struc);
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_partitioner_args(");
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_partitioner_result : TBase
    {
      private string _success;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public describe_partitioner_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_partitioner_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_partitioner_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_snitch_args : TBase
    {

      public describe_snitch_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_snitch_args");
          oprot.WriteStructBegin(struc);
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_snitch_args(");
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_snitch_result : TBase
    {
      private string _success;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public describe_snitch_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_snitch_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_snitch_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_keyspace_args : TBase
    {

      public string Keyspace { get; set; }

      public describe_keyspace_args() {
      }

      public describe_keyspace_args(string keyspace) : this() {
        this.Keyspace = keyspace;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_keyspace = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Keyspace = iprot.ReadString();
                  isset_keyspace = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_keyspace)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_keyspace_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "keyspace";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Keyspace);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_keyspace_args(");
        __sb.Append(", Keyspace: ");
        __sb.Append(Keyspace);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_keyspace_result : TBase
    {
      private KsDef _success;
      private NotFoundException _nfe;
      private InvalidRequestException _ire;

      public KsDef Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public NotFoundException Nfe
      {
        get
        {
          return _nfe;
        }
        set
        {
          __isset.nfe = true;
          this._nfe = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool nfe;
        public bool ire;
      }

      public describe_keyspace_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new KsDef();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Nfe = new NotFoundException();
                  Nfe.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_keyspace_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.nfe) {
            if (Nfe != null) {
              field.Name = "Nfe";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Nfe.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_keyspace_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (Nfe != null && __isset.nfe) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Nfe: ");
          __sb.Append(Nfe== null ? "<null>" : Nfe.ToString());
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_splits_args : TBase
    {

      public string CfName { get; set; }

      public string Start_token { get; set; }

      public string End_token { get; set; }

      public int Keys_per_split { get; set; }

      public describe_splits_args() {
      }

      public describe_splits_args(string cfName, string start_token, string end_token, int keys_per_split) : this() {
        this.CfName = cfName;
        this.Start_token = start_token;
        this.End_token = end_token;
        this.Keys_per_split = keys_per_split;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_cfName = false;
          bool isset_start_token = false;
          bool isset_end_token = false;
          bool isset_keys_per_split = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  CfName = iprot.ReadString();
                  isset_cfName = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Start_token = iprot.ReadString();
                  isset_start_token = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  End_token = iprot.ReadString();
                  isset_end_token = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  Keys_per_split = iprot.ReadI32();
                  isset_keys_per_split = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_cfName)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_start_token)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_end_token)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_keys_per_split)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_splits_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "cfName";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(CfName);
          oprot.WriteFieldEnd();
          field.Name = "start_token";
          field.Type = TType.String;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Start_token);
          oprot.WriteFieldEnd();
          field.Name = "end_token";
          field.Type = TType.String;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(End_token);
          oprot.WriteFieldEnd();
          field.Name = "keys_per_split";
          field.Type = TType.I32;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32(Keys_per_split);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_splits_args(");
        __sb.Append(", CfName: ");
        __sb.Append(CfName);
        __sb.Append(", Start_token: ");
        __sb.Append(Start_token);
        __sb.Append(", End_token: ");
        __sb.Append(End_token);
        __sb.Append(", Keys_per_split: ");
        __sb.Append(Keys_per_split);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class describe_splits_result : TBase
    {
      private List<string> _success;
      private InvalidRequestException _ire;

      public List<string> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
      }

      public describe_splits_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<string>();
                    TList _list148 = iprot.ReadListBegin();
                    for( int _i149 = 0; _i149 < _list148.Count; ++_i149)
                    {
                      string _elem150;
                      _elem150 = iprot.ReadString();
                      Success.Add(_elem150);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("describe_splits_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.String, Success.Count));
                foreach (string _iter151 in Success)
                {
                  oprot.WriteString(_iter151);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("describe_splits_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_add_column_family_args : TBase
    {

      public CfDef Cf_def { get; set; }

      public system_add_column_family_args() {
      }

      public system_add_column_family_args(CfDef cf_def) : this() {
        this.Cf_def = cf_def;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_cf_def = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Cf_def = new CfDef();
                  Cf_def.Read(iprot);
                  isset_cf_def = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_cf_def)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_add_column_family_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "cf_def";
          field.Type = TType.Struct;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          Cf_def.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_add_column_family_args(");
        __sb.Append(", Cf_def: ");
        __sb.Append(Cf_def== null ? "<null>" : Cf_def.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_add_column_family_result : TBase
    {
      private string _success;
      private InvalidRequestException _ire;
      private SchemaDisagreementException _sde;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public SchemaDisagreementException Sde
      {
        get
        {
          return _sde;
        }
        set
        {
          __isset.sde = true;
          this._sde = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool sde;
      }

      public system_add_column_family_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Sde = new SchemaDisagreementException();
                  Sde.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_add_column_family_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.sde) {
            if (Sde != null) {
              field.Name = "Sde";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Sde.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_add_column_family_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Sde != null && __isset.sde) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Sde: ");
          __sb.Append(Sde== null ? "<null>" : Sde.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_drop_column_family_args : TBase
    {

      public string Column_family { get; set; }

      public system_drop_column_family_args() {
      }

      public system_drop_column_family_args(string column_family) : this() {
        this.Column_family = column_family;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_column_family = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Column_family = iprot.ReadString();
                  isset_column_family = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_column_family)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_drop_column_family_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "column_family";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Column_family);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_drop_column_family_args(");
        __sb.Append(", Column_family: ");
        __sb.Append(Column_family);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_drop_column_family_result : TBase
    {
      private string _success;
      private InvalidRequestException _ire;
      private SchemaDisagreementException _sde;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public SchemaDisagreementException Sde
      {
        get
        {
          return _sde;
        }
        set
        {
          __isset.sde = true;
          this._sde = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool sde;
      }

      public system_drop_column_family_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Sde = new SchemaDisagreementException();
                  Sde.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_drop_column_family_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.sde) {
            if (Sde != null) {
              field.Name = "Sde";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Sde.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_drop_column_family_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Sde != null && __isset.sde) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Sde: ");
          __sb.Append(Sde== null ? "<null>" : Sde.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_add_keyspace_args : TBase
    {

      public KsDef Ks_def { get; set; }

      public system_add_keyspace_args() {
      }

      public system_add_keyspace_args(KsDef ks_def) : this() {
        this.Ks_def = ks_def;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_ks_def = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Ks_def = new KsDef();
                  Ks_def.Read(iprot);
                  isset_ks_def = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_ks_def)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_add_keyspace_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "ks_def";
          field.Type = TType.Struct;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          Ks_def.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_add_keyspace_args(");
        __sb.Append(", Ks_def: ");
        __sb.Append(Ks_def== null ? "<null>" : Ks_def.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_add_keyspace_result : TBase
    {
      private string _success;
      private InvalidRequestException _ire;
      private SchemaDisagreementException _sde;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public SchemaDisagreementException Sde
      {
        get
        {
          return _sde;
        }
        set
        {
          __isset.sde = true;
          this._sde = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool sde;
      }

      public system_add_keyspace_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Sde = new SchemaDisagreementException();
                  Sde.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_add_keyspace_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.sde) {
            if (Sde != null) {
              field.Name = "Sde";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Sde.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_add_keyspace_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Sde != null && __isset.sde) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Sde: ");
          __sb.Append(Sde== null ? "<null>" : Sde.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_drop_keyspace_args : TBase
    {

      public string Keyspace { get; set; }

      public system_drop_keyspace_args() {
      }

      public system_drop_keyspace_args(string keyspace) : this() {
        this.Keyspace = keyspace;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_keyspace = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Keyspace = iprot.ReadString();
                  isset_keyspace = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_keyspace)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_drop_keyspace_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "keyspace";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Keyspace);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_drop_keyspace_args(");
        __sb.Append(", Keyspace: ");
        __sb.Append(Keyspace);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_drop_keyspace_result : TBase
    {
      private string _success;
      private InvalidRequestException _ire;
      private SchemaDisagreementException _sde;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public SchemaDisagreementException Sde
      {
        get
        {
          return _sde;
        }
        set
        {
          __isset.sde = true;
          this._sde = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool sde;
      }

      public system_drop_keyspace_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Sde = new SchemaDisagreementException();
                  Sde.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_drop_keyspace_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.sde) {
            if (Sde != null) {
              field.Name = "Sde";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Sde.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_drop_keyspace_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Sde != null && __isset.sde) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Sde: ");
          __sb.Append(Sde== null ? "<null>" : Sde.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_update_keyspace_args : TBase
    {

      public KsDef Ks_def { get; set; }

      public system_update_keyspace_args() {
      }

      public system_update_keyspace_args(KsDef ks_def) : this() {
        this.Ks_def = ks_def;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_ks_def = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Ks_def = new KsDef();
                  Ks_def.Read(iprot);
                  isset_ks_def = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_ks_def)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_update_keyspace_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "ks_def";
          field.Type = TType.Struct;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          Ks_def.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_update_keyspace_args(");
        __sb.Append(", Ks_def: ");
        __sb.Append(Ks_def== null ? "<null>" : Ks_def.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_update_keyspace_result : TBase
    {
      private string _success;
      private InvalidRequestException _ire;
      private SchemaDisagreementException _sde;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public SchemaDisagreementException Sde
      {
        get
        {
          return _sde;
        }
        set
        {
          __isset.sde = true;
          this._sde = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool sde;
      }

      public system_update_keyspace_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Sde = new SchemaDisagreementException();
                  Sde.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_update_keyspace_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.sde) {
            if (Sde != null) {
              field.Name = "Sde";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Sde.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_update_keyspace_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Sde != null && __isset.sde) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Sde: ");
          __sb.Append(Sde== null ? "<null>" : Sde.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_update_column_family_args : TBase
    {

      public CfDef Cf_def { get; set; }

      public system_update_column_family_args() {
      }

      public system_update_column_family_args(CfDef cf_def) : this() {
        this.Cf_def = cf_def;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_cf_def = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Cf_def = new CfDef();
                  Cf_def.Read(iprot);
                  isset_cf_def = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_cf_def)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_update_column_family_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "cf_def";
          field.Type = TType.Struct;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          Cf_def.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_update_column_family_args(");
        __sb.Append(", Cf_def: ");
        __sb.Append(Cf_def== null ? "<null>" : Cf_def.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class system_update_column_family_result : TBase
    {
      private string _success;
      private InvalidRequestException _ire;
      private SchemaDisagreementException _sde;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public SchemaDisagreementException Sde
      {
        get
        {
          return _sde;
        }
        set
        {
          __isset.sde = true;
          this._sde = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool sde;
      }

      public system_update_column_family_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Sde = new SchemaDisagreementException();
                  Sde.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("system_update_column_family_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.sde) {
            if (Sde != null) {
              field.Name = "Sde";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Sde.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("system_update_column_family_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Sde != null && __isset.sde) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Sde: ");
          __sb.Append(Sde== null ? "<null>" : Sde.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class execute_cql_query_args : TBase
    {

      public byte[] Query { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="Compression"/>
      /// </summary>
      public Compression Compression { get; set; }

      public execute_cql_query_args() {
      }

      public execute_cql_query_args(byte[] query, Compression compression) : this() {
        this.Query = query;
        this.Compression = compression;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_query = false;
          bool isset_compression = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Query = iprot.ReadBinary();
                  isset_query = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.I32) {
                  Compression = (Compression)iprot.ReadI32();
                  isset_compression = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_query)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_compression)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("execute_cql_query_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "query";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Query);
          oprot.WriteFieldEnd();
          field.Name = "compression";
          field.Type = TType.I32;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Compression);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("execute_cql_query_args(");
        __sb.Append(", Query: ");
        __sb.Append(Query);
        __sb.Append(", Compression: ");
        __sb.Append(Compression);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class execute_cql_query_result : TBase
    {
      private CqlResult _success;
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;
      private SchemaDisagreementException _sde;

      public CqlResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }

      public SchemaDisagreementException Sde
      {
        get
        {
          return _sde;
        }
        set
        {
          __isset.sde = true;
          this._sde = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool ue;
        public bool te;
        public bool sde;
      }

      public execute_cql_query_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new CqlResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Struct) {
                  Sde = new SchemaDisagreementException();
                  Sde.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("execute_cql_query_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.sde) {
            if (Sde != null) {
              field.Name = "Sde";
              field.Type = TType.Struct;
              field.ID = 4;
              oprot.WriteFieldBegin(field);
              Sde.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("execute_cql_query_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        if (Sde != null && __isset.sde) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Sde: ");
          __sb.Append(Sde== null ? "<null>" : Sde.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class prepare_cql_query_args : TBase
    {

      public byte[] Query { get; set; }

      /// <summary>
      /// 
      /// <seealso cref="Compression"/>
      /// </summary>
      public Compression Compression { get; set; }

      public prepare_cql_query_args() {
      }

      public prepare_cql_query_args(byte[] query, Compression compression) : this() {
        this.Query = query;
        this.Compression = compression;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_query = false;
          bool isset_compression = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Query = iprot.ReadBinary();
                  isset_query = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.I32) {
                  Compression = (Compression)iprot.ReadI32();
                  isset_compression = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_query)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_compression)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("prepare_cql_query_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "query";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Query);
          oprot.WriteFieldEnd();
          field.Name = "compression";
          field.Type = TType.I32;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)Compression);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("prepare_cql_query_args(");
        __sb.Append(", Query: ");
        __sb.Append(Query);
        __sb.Append(", Compression: ");
        __sb.Append(Compression);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class prepare_cql_query_result : TBase
    {
      private CqlPreparedResult _success;
      private InvalidRequestException _ire;

      public CqlPreparedResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
      }

      public prepare_cql_query_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new CqlPreparedResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("prepare_cql_query_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("prepare_cql_query_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class execute_prepared_cql_query_args : TBase
    {

      public int ItemId { get; set; }

      public List<string> Values { get; set; }

      public execute_prepared_cql_query_args() {
      }

      public execute_prepared_cql_query_args(int itemId, List<string> values) : this() {
        this.ItemId = itemId;
        this.Values = values;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_itemId = false;
          bool isset_values = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.I32) {
                  ItemId = iprot.ReadI32();
                  isset_itemId = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    Values = new List<string>();
                    TList _list152 = iprot.ReadListBegin();
                    for( int _i153 = 0; _i153 < _list152.Count; ++_i153)
                    {
                      string _elem154;
                      _elem154 = iprot.ReadString();
                      Values.Add(_elem154);
                    }
                    iprot.ReadListEnd();
                  }
                  isset_values = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_itemId)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
          if (!isset_values)
            throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("execute_prepared_cql_query_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "itemId";
          field.Type = TType.I32;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32(ItemId);
          oprot.WriteFieldEnd();
          field.Name = "values";
          field.Type = TType.List;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.String, Values.Count));
            foreach (string _iter155 in Values)
            {
              oprot.WriteString(_iter155);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("execute_prepared_cql_query_args(");
        __sb.Append(", ItemId: ");
        __sb.Append(ItemId);
        __sb.Append(", Values: ");
        __sb.Append(Values);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class execute_prepared_cql_query_result : TBase
    {
      private CqlResult _success;
      private InvalidRequestException _ire;
      private UnavailableException _ue;
      private TimedOutException _te;
      private SchemaDisagreementException _sde;

      public CqlResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public InvalidRequestException Ire
      {
        get
        {
          return _ire;
        }
        set
        {
          __isset.ire = true;
          this._ire = value;
        }
      }

      public UnavailableException Ue
      {
        get
        {
          return _ue;
        }
        set
        {
          __isset.ue = true;
          this._ue = value;
        }
      }

      public TimedOutException Te
      {
        get
        {
          return _te;
        }
        set
        {
          __isset.te = true;
          this._te = value;
        }
      }

      public SchemaDisagreementException Sde
      {
        get
        {
          return _sde;
        }
        set
        {
          __isset.sde = true;
          this._sde = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool ire;
        public bool ue;
        public bool te;
        public bool sde;
      }

      public execute_prepared_cql_query_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new CqlResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Ire = new InvalidRequestException();
                  Ire.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ue = new UnavailableException();
                  Ue.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Te = new TimedOutException();
                  Te.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Struct) {
                  Sde = new SchemaDisagreementException();
                  Sde.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("execute_prepared_cql_query_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ire) {
            if (Ire != null) {
              field.Name = "Ire";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Ire.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ue) {
            if (Ue != null) {
              field.Name = "Ue";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ue.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.te) {
            if (Te != null) {
              field.Name = "Te";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Te.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.sde) {
            if (Sde != null) {
              field.Name = "Sde";
              field.Type = TType.Struct;
              field.ID = 4;
              oprot.WriteFieldBegin(field);
              Sde.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("execute_prepared_cql_query_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (Ire != null && __isset.ire) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ire: ");
          __sb.Append(Ire== null ? "<null>" : Ire.ToString());
        }
        if (Ue != null && __isset.ue) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ue: ");
          __sb.Append(Ue== null ? "<null>" : Ue.ToString());
        }
        if (Te != null && __isset.te) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Te: ");
          __sb.Append(Te== null ? "<null>" : Te.ToString());
        }
        if (Sde != null && __isset.sde) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Sde: ");
          __sb.Append(Sde== null ? "<null>" : Sde.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }

  }
}
